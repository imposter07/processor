<style type="text/css">
    .widget {
        height: 25vh;
        width: 175px;
        margin-left: auto;
        margin-right: auto;
    }

    .overlay {
        fill: none;
        pointer-events: all;
    }

    .radial-progress-bar {
        fill: #ddd;
        margin-left: auto;
        margin-right: auto;
        margin-top: auto;
    }

    .radial-progress-bar-bg {
        fill: #3f3f3f;
    }

    .progress-label {
        fill: #aaa;
        font-family: 'Open Sans', sans-serif;
        font-size: 15px;
        text-anchor: middle;
        dominant-baseline: central;
    }

    .outer {
        overflow: auto;
    }
</style>

<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/holtzy/D3-graph-gallery@master/LIB/d3-scale-radial.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
    function autoMargin(elem, maxHeight, lMargin, bMargin, dataLength = 1,
                        dataLengthY = 1) {
        const parent = d3.select(elem)
        const size = parent.node().getBoundingClientRect()
        let margin = {top: 10, right: 10, bottom: bMargin, left: lMargin},
            width = (size.width - margin.left - margin.right) * dataLength,
            height = (maxHeight - margin.top - margin.bottom) * dataLengthY;
        let svgHeight = height + margin.top + margin.bottom
        let svg = parent
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", svgHeight)
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");
        return {margin: margin, width: width, height: height, svg: svg}
    }

    function generateSelect(elem, allGroup, selectElem = 'Select') {
        let buttonSelector = elem + selectElem;
        $(buttonSelector).html('' +
            '<select id="' + buttonSelector + ' " ' +
            'class="form-control form-control-sm">' +
            '<option>Select Metric</option>' +
            '</select>'
        )
        d3.select(buttonSelector)
            .selectAll('myOptions')
            .data(allGroup)
            .enter()
            .append('option')
            .text(function (d) {
                return d;
            }) // text showed in the menu
            .attr("value", function (d) {
                return d;
            }) // corresponding value returned by the button
        allGroup = allGroup.map(x => {
            return ({text: x});
        });
        addSelectOptions(allGroup, '', buttonSelector)
    }

    function wrapText(text, width) {
        text.each(function () {
            var text = d3.select(this),
                words = text.text().split(/[ _]+/).reverse(),
                word,
                line = [],
                lineNumber = 0,
                lineHeight = 1.1, // ems
                y = text.attr("y"),
                dy = parseFloat(text.attr("dy")),
                tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(" "));
                if (tspan.node().getComputedTextLength() > width) {
                    line.pop();
                    tspan.text(line.join(" "));
                    line = [word];
                    tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                }
            }
        });
    }

    function generateAxis(data, svg, xAxisType, yAxisType, width, height,
                          xCol, yCol, timeX = null) {

        let xDomain = function () {
            if (timeX) {
                return d3.extent(data, function (d) {
                    return d[xCol];
                })
            } else {
                return data.map(function (d) {
                    return d[xCol];
                })
            }
        }
        let x = xAxisType
            .domain(xDomain())
            .range([0, width])
        if (!timeX) {
            x.padding(1)
        }
        let xAxis = d3.axisBottom(x)
        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .attr('class', 'xaxis')
            .call(xAxis);
        if (!timeX) {
            svg.selectAll('.xaxis')
                .selectAll(".tick text")
                .call(wrapText, x.bandwidth());
        }

        let yScale = yAxisType
            .domain([0, d3.max(data, function (d) {
                return +d[yCol];
            })])
            .range([height, 0]);
        let yAxis = d3.axisLeft(yScale);
        svg.append("g")
            .attr('class', 'yaxis')
            .call(yAxis);
        return {x: x, yScale: yScale, yAxis: yAxis, xAxis: xAxis}
    }

    function getColorPal(allGroup) {
        let myColor = d3.scaleOrdinal()
            .domain(allGroup)
            .range(d3.schemeTableau10);
        return myColor
    }

    function sortData(data, col) {
        return data.sort((a, b) => b[col] - a[col])
    }

    function updateYAxis(axes, data, svg, selectedVar) {
        axes.yScale.domain([0, d3.max(data, function (d) {
            return +d[selectedVar]
        })]);
        svg.selectAll(".yaxis")
            .transition().duration(500)
            .call(axes.yAxis)
    }

    function addToolTip(svg, am, axes, data, xCol, selectedVar, myColor, timeX) {
        let dateFormatter = d3.timeFormat("%m/%d/%y");
        let formatValue = d3.format(",");
        let focus = svg.append("g")
            .attr("class", "focus");

        focus.append("circle")
            .attr("r", 5)
            .attr("fill", function (d) {
                return myColor(selectedVar)
            });

        focus.append("div")
            .style("opacity", 0)
            .attr("class", "tooltip")
            .style("background-color", "white")
            .style("border", "solid")
            .style("border-width", "2px")
            .style("border-radius", "5px")
            .style("padding", "5px");

        focus.append("text")
            .attr("class", "tooltip-x")
            .attr("x", 18)
            .attr("y", -2);

        focus.append("text")
            .attr("class", "tooltip-y")
            .attr("x", 18)
            .attr("y", 18);

        svg.append("rect")
            .attr("class", "overlay")
            .attr("width", am.width)
            .attr("height", am.height)
            .on("mouseover", function () {
                focus.attr("display", null);
                focus.attr("fill-opacity", .7)
            })
            .on("mouseout", function () {
                focus.attr("display", "none");
                focus.attr("fill-opacity", .3)
            })
            .on("mousemove", mousemove);
        let bisectDate = d3.bisector(function (d) {
            return d[xCol];
        }).left

        function mousemove() {
            let dGet = function (currentThis) {
                if (timeX) {
                    let x0 = axes.x.invert(d3.mouse(currentThis)[0])
                    let i = bisectDate(data, x0, 1)
                    let d0 = data[i - 1]
                    let d1 = data[i];
                    return x0 - d0[xCol] > d1[xCol] - x0 ? d1 : d0
                } else {
                    let mx = d3.mouse(currentThis)[0] // x position of cursor
                    let idx = Math.round((mx / axes.x.step()) - axes.x.padding())
                    return data[idx]
                }
            }
            let d = dGet(this)
            let xColVal = (timeX) ? dateFormatter(d[xCol]) : d[xCol]
            focus.attr("transform", "translate(" + axes.x(d[xCol]) + "," + axes.yScale(d[selectedVar]) + ")");
            focus.select(".tooltip-x").text(xCol + ": " + xColVal);
            focus.select(".tooltip-y").text(selectedVar + ": " + formatValue(d[selectedVar]));
            focus.style("left", (d3.mouse(this)[0] + 70) + "px");
            focus.style("top", (d3.mouse(this)[1]) + "px");
        }
    }

    function getAreaGenerator(axes, xCol, selectedVar) {
        return d3.area()
            .x(function (d) {
                return axes.x(d[xCol])
            })
            .y0(axes.yScale(0))
            .y1(function (d) {
                return axes.yScale(d[selectedVar])
            })
            .curve(d3.curveMonotoneX)
    }

    function addClipBrush(svg, am, idleTimeout, idled, axes, u, xCol, selectedVar) {
        // Add brushing
        var clip = svg.append("defs").append("svg:clipPath")
            .attr("id", "clip")
            .append("svg:rect")
            .attr("width", am.width)
            .attr("height", am.height)
            .attr("x", 0)
            .attr("y", 0);

        // Add brushing
        var brush = d3.brushX()                   // Add the brush feature using the d3.brush function
            .extent([[0, 0], [am.width, am.height]])  // initialise the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
            .on("end", updateChartFromClipBrush)               // Each time the brush selection changes, trigger the 'updateChart' function

        function updateChartFromClipBrush() {

            // What are the selected boundaries?
            let extent = d3.event.selection
            // If no selection, back to initial coordinate. Otherwise, update X axis domain
            if (!extent) {
                if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // This allows to wait a little bit
                axes.x.domain([4, 8])
            } else {
                axes.x.domain([axes.x.invert(extent[0]), axes.x.invert(extent[1])])
                u.select(".brush").call(brush.move, null) // This remove the grey brush area as soon as the selection has been done
            }
            // Update axis and area position
            svg.selectAll(".xaxis")
                .transition().duration(500)
                .call(axes.xAxis)
            let areaGenerator = getAreaGenerator(axes, xCol, selectedVar)
            u
                .select('.lineTest')
                .transition()
                .duration(1000)
                .attr("d", areaGenerator)
        }

        return {clip: clip, brush: brush}
    }

    function groupData() {
        var nested_data = d3.nest()
            .key(function (d) {
                return d.Clicked;
            })
            .key(function (d) {
                return d.Campaign
            })
            .rollup(function (values) {
                return values.length;
            })
            .entries(data);
    }

    function generateHistogram() {
        // set the dimensions and margins of the graph
        var margin = {top: 10, right: 30, bottom: 30, left: 40},
            width = 460 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg = d3.select("#my_dataviz")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");

        // get the data
        d3.json("/get_metrics").then(function (data) {

            // X axis: scale and draw:
            var x = d3.scaleLinear()
                .domain([0, 1000])     // can use this instead of 1000 to have the max of data: d3.max(data, function(d) { return +d.price })
                .range([0, width]);
            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // set the parameters for the histogram
            var histogram = d3.histogram()
                .value(function (d) {
                    return d.price;
                })   // I need to give the vector of value
                .domain(x.domain())  // then the domain of the graphic
                .thresholds(x.ticks(70)); // then the numbers of bins

            // And apply this function to data to get the bins
            var bins = histogram(data);

            // Y axis: scale and draw:
            var y = d3.scaleLinear()
                .range([height, 0]);
            y.domain([0, d3.max(bins, function (d) {
                return d.length;
            })]);   // d3.hist has to be called before the Y axis obviously
            svg.append("g")
                .call(d3.axisLeft(y));

            // append the bar rectangles to the svg element
            svg.selectAll("rect")
                .data(bins)
                .enter()
                .append("rect")
                .attr("x", 1)
                .attr("transform", function (d) {
                    return "translate(" + x(d.x0) + "," + y(d.length) + ")";
                })
                .attr("width", function (d) {
                    return x(d.x1) - x(d.x0) - 1;
                })
                .attr("height", function (d) {
                    return height - y(d.length);
                })
                .style("fill", "#69b3a2")

        });
    }

    function generateLineChart(elem, data, xCol, yCol) {
        let am = autoMargin(elem, 500, 60, 30);
        let svg = am.svg
        let parseDate = d3.timeParse("%Y-%m-%d");
        data.forEach(function (d) {
            d[xCol] = parseDate(d[xCol]);
        });
        generateSelect(elem, yCol)
        // A color scale: one color for each group
        let myColor = getColorPal(yCol)
        let axes = generateAxis(
            data, svg, d3.scaleTime(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], true
        )
        // A function that update the chart
        function update(selectedVar) {
            updateYAxis(axes, data, svg, selectedVar)
            let u = svg.selectAll(".lineTest")
                .data([data])
            u
                .enter()
                .append("path")
                .attr("class", "lineTest")
                .merge(u)
                .transition()
                .duration(1000)
                .attr("d", d3.line()
                    .x(function (d) {
                        return axes.x(d[xCol])
                    })
                    .y(function (d) {
                        return axes.yScale(d[selectedVar])
                    })
                    .curve(d3.curveMonotoneX)
                )
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 4)
                .attr("fill", "none")
            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor, true)
        }
        // When the button is changed, run the updateChart function
        d3.select(elem + 'Select').on("change", function (d) {
            // recover the option that has been chosen
            let selectedOption = d3.select(this).property("value")
            // run the updateChart function with this selected option
            update(selectedOption)
        })
        update(yCol[0])
    }

    function generateAreaChart(elem, data, xCol, yCol, filterCols) {
        let am = autoMargin(elem, 250, 60, 30);
        let svg = am.svg
        let parseDate = d3.timeParse("%Y-%m-%d");
        data.forEach(function (d) {
            d[xCol] = parseDate(d[xCol]);
        });
        generateSelect(elem, yCol)
        // generateSelect(elem, filterCols, 'SelectDimension')
        // A color scale: one color for each group
        let myColor = getColorPal(yCol)
        let axes = generateAxis(
            data, svg, d3.scaleTime(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], true
        )

        // A function that update the chart
        function update(selectedVar, selectedDim = null) {
            updateYAxis(axes, data, svg, selectedVar)
            let areaGenerator = getAreaGenerator(axes, xCol, selectedVar)
            let u = svg.selectAll(".lineTest")
                .data([data])
                .attr("clip-path", "url(#clip)")
            u
                .enter()
                .append("path")
                .attr("class", "lineTest")
                .merge(u)
                .transition()
                .duration(1000)
                .attr("d", areaGenerator)
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 1)
                .attr("fill-opacity", .3)
                .attr("fill", function (d) {
                    return myColor(selectedVar)
                })
            var idleTimeout = null

            function idled() {
                idleTimeout = null;
            }

            let clipBrush = addClipBrush(svg, am, idleTimeout,
                idled, axes, u, xCol, selectedVar)
            u
                .enter()
                .append("g")
                .attr("class", "brush")
                .call(clipBrush.brush);
            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor, true)
        }

        $(elem + 'Select').on("change", function (e) {
            let selectedOption = $(e.currentTarget).val();
            update(selectedOption)
        })

        // If user double click, reinitialize the chart
        svg.on("dblclick", function () {
            axes.x.domain(d3.extent(data, function (d) {
                return d[xCol];
            }))
            svg.selectAll(".xaxis")
                .transition().duration(500)
                .call(axes.xAxis)
            update(yCol[0])
        });
        update(yCol[0])
    }

    function generateLollipopChart(elem, data, xCol, yCol) {
        data = sortData(data, yCol[0])
        let dataLength = (data.length < 20) ? 1 : data.length / 20
        let am = autoMargin(elem, 250, 60, 30, dataLength);
        let svg = am.svg
        generateSelect(elem, yCol)
        let myColor = getColorPal(yCol)
        let axes = generateAxis(
            data, svg, d3.scaleBand(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], false
        )

        function update(selectedVar) {
            // Add Y axis
            axes.yScale.domain([0, d3.max(data, function (d) {
                return +d[selectedVar]
            })]);
            svg.selectAll(".yaxis")
                .transition().duration(500)
                .call(axes.yAxis)
            // variable u: map data to existing circle
            var j = svg.selectAll(".myLine")
                .data(data)
            // update lines
            j
                .enter()
                .append("line")
                .attr("class", "myLine")
                .merge(j)
                .transition()
                .duration(1000)
                .attr("x1", function (d) {
                    return axes.x(d[xCol]);
                })
                .attr("x2", function (d) {
                    return axes.x(d[xCol]);
                })
                .attr("y1", axes.yScale(0))
                .attr("y2", function (d) {
                    return axes.yScale(d[selectedVar]);
                })
                .attr("stroke", "grey")


            // variable u: map data to existing circle
            var u = svg.selectAll("circle")
                .data(data)
            // update bars
            u
                .enter()
                .append("circle")
                .merge(u)
                .transition()
                .duration(1000)
                .attr("cx", function (d) {
                    return axes.x(d[xCol]);
                })
                .attr("cy", function (d) {
                    return axes.yScale(d[selectedVar]);
                })
                .attr("r", 8)
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 1)
                .attr("fill", function (d) {
                    return myColor(selectedVar)
                })
                .attr("fill-opacity", .3)

            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor)
        }

        $(elem + 'Select').on("change", function (e) {
            let selectedOption = $(e.currentTarget).val();
            update(selectedOption)
        })

        update(yCol[0])
    }

    function generateMiniChart(elem, axes, am) {

        var svg = d3.select("svg"),
            margin2 = {top: 430, right: 20, bottom: 30, left: 40},
            width = +svg.attr("width") - axes.margin.left - axes.margin.right,
            height2 = +svg.attr("height") - margin2.top - margin2.bottom;
        var x2 = d3.scaleTime().range([0, width]),
            y2 = d3.scaleLinear().range([height2, 0]);

        var xAxis2 = d3.axisBottom(x2)

        var brush = d3.brushX()
            .extent([[0, 0], [width, height2]])
            .on("brush end", brushed);

        var zoom = d3.zoom()
            .scaleExtent([1, Infinity])
            .translateExtent([[0, 0], [width, am.height]])
            .extent([[0, 0], [width, am.height]])
            .on("zoom", zoomed);

        var area2 = d3.area()
            .curve(d3.curveMonotoneX)
            .x(function (d) {
                return x2(d[xCol]);
            })
            .y0(height2)
            .y1(function (d) {
                return y2(d[selectedVar]);
            });

        svg.append("defs").append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("width", width)
            .attr("height", height);

        var focus = svg.append("g")
            .attr("class", "focus")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var context = svg.append("g")
            .attr("class", "context")
            .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

        function brushed() {
            if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
            var s = d3.event.selection || x2.range();
            x.domain(s.map(x2.invert, x2));
            focus.select(".area").attr("d", area);
            focus.select(".axis--x").call(xAxis);
            svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
                .scale(width / (s[1] - s[0]))
                .translate(-s[0], 0));
        }

        function zoomed() {
            if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
            var t = d3.event.transform;
            x.domain(t.rescaleX(x2).domain());
            focus.select(".area").attr("d", area);
            focus.select(".axis--x").call(xAxis);
            context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
        }

        function type(d) {
            d.date = parseDate(d.date);
            d.price = +d.price;
            return d;
        }
    }

    function generateBarChart(elem, data, xCol, yCol) {
        data = sortData(data, yCol[0])
        let dataLength = (data.length < 10) ? 1 : data.length / 10
        let am = autoMargin(elem, 250, 60, 30, dataLength);
        let svg = am.svg
        generateSelect(elem, yCol)
        // A color scale: one color for each group
        let myColor = getColorPal(yCol)
        let axes = generateAxis(
            data, svg, d3.scaleBand(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], false
        )

        function update(selectedVar) {
            // Add Y axis
            axes.yScale.domain([0, d3.max(data, function (d) {
                return +d[selectedVar]
            })]);
            svg.selectAll(".yaxis")
                .transition().duration(500)
                .call(axes.yAxis)
            // variable u: map data to existing circle
            var j = svg.selectAll(".bar")
                .data(data)
            // update lines
            j
                .enter()
                .append("rect")
                .attr("class", "bar")
                .merge(j)
                .transition()
                .duration(1000)
                .attr("x", function (d) {
                    return axes.x(d[xCol]);
                })
                .attr("y", function (d) {
                    return axes.yScale(d[selectedVar]);
                })
                .attr("width", 20)
                .attr("height", function (d) {
                    return am.height - axes.yScale(d[selectedVar]);
                })
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 1)
                .attr("fill", function (d) {
                    return myColor(selectedVar)
                })
                .attr("fill-opacity", .3)
            // generateMiniChart(elem)
            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor)
        }

        $(elem + 'Select').on("change", function (e) {
            let selectedOption = $(e.currentTarget).val();
            update(selectedOption)
        })

        update(yCol[0])
    }

    function generateWorldMap(elem, data, xCol, yCol) {
        let am = autoMargin(elem, 500, 0, 0);    // example data from server
    }

    function generateCircularBarplot(elem, data, xCol, yCol) {
        data = sortData(data, yCol[0])
        const parent = d3.select(elem)
        const size = parent.node().getBoundingClientRect()
        const svg = parent.append('svg')
            .attr('width', size.width)
            .attr('height', 500)
            .append("g")
            .attr("transform", "translate(" + (size.width / 2) + "," + (250) + ")");

        let innerRadius = 10;
        let outerRadius = Math.min(size.width, 250) / 2;

        var x = d3.scaleBand()
            .range([0, 2 * Math.PI])    // X axis goes from 0 to 2pi = all around the circle. If I stop at 1Pi, it will be around a half circle
            .align(0)                  // This does nothing
            .domain(data.map(function (d) {
                return d[xCol];
            })); // The domain of the X axis is the list of states.
        var y = d3.scaleRadial()
            .range([innerRadius, outerRadius])   // Domain will be define later.
            .domain([0, 100000]); // Domain of Y is from 0 to the max seen in the data

        var ybis = d3.scaleRadial()
            .range([innerRadius, 5])   // Domain will be defined later.
            .domain([0, 100000]);

        // Add the bars
        svg.append("g")
            .selectAll("path")
            .data(data)
            .enter()
            .append("path")
            .attr("fill", "#69b3a2")
            .attr("d", d3.arc()     // imagine your doing a part of a donut plot
                .innerRadius(innerRadius)
                .outerRadius(function (d) {
                    return y(d[yCol[1]] - d[yCol[0]]);
                })
                .startAngle(function (d) {
                    return x(d[xCol]);
                })
                .endAngle(function (d) {
                    return x(d[xCol]) + x.bandwidth();
                })
                .padAngle(0.01)
                .padRadius(innerRadius))

        svg.append("g")
            .selectAll("g")
            .data(data)
            .enter()
            .append("g")
            .attr("text-anchor", function (d) {
                return (x(d[xCol]) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "end" : "start";
            })
            .attr("transform", function (d) {
                return "rotate(" + ((x(d[xCol]) + x.bandwidth() / 2) * 180 / Math.PI - 90) + ")" + "translate(" + (y(d[yCol[0]]) + 10) + ",0)";
            })
            .append("text")
            .text(function (d) {
                return (d[xCol])
            })
            .attr("transform", function (d) {
                return (x(d[xCol]) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "rotate(180)" : "rotate(0)";
            })
            .style("font-size", "11px")
            .attr("alignment-baseline", "middle")
        svg.append("g")
            .selectAll("path")
            .data(data)
            .enter()
            .append("path")
            .attr("fill", "red")
            .attr("d", d3.arc()     // imagine your doing a part of a donut plot
                .innerRadius(function (d) {
                    return ybis(0)
                })
                .outerRadius(function (d) {
                    return ybis(d[yCol[0]]);
                })
                .startAngle(function (d) {
                    return x(d[xCol]);
                })
                .endAngle(function (d) {
                    return x(d[xCol]) + x.bandwidth();
                })
                .padAngle(0.01)
                .padRadius(innerRadius))
    }

    function generateProgressBars(elem, data, xCol, yCol) {
        data.sort((a, b) => b[yCol[0]] - a[yCol[0]])
        generateSelect(elem, yCol)
        let dataLength = (data.length < 5) ? 1 : data.length / 5
        let am = autoMargin(elem, 250, 5, 5, 1, dataLength)
        let xVal = 10
        let barHeight = 20
        let spacing = 50
        let scale = d3.scaleLinear()
            .domain([0, 1])
            .range([0, am.width]);
        am.svg.selectAll("g")
            .data(data)
            .enter()
            .append("rect")
            .attr("x", xVal)
            .attr("y", function (d, i) {
                return barHeight + i * spacing
            })
            .attr("height", barHeight)
            .attr("width", function (d) {
                return scale(scale.domain()[1])
            })
            .attr("rx", 5)
            .attr("ry", 5)
            .style("fill", "#ddd");

        am.svg.selectAll("g")
            .data(data)
            .enter()
            .append("rect")
            .attr("x", xVal)
            .attr("y", function (d, i) {
                return barHeight + i * spacing
            })
            .attr("height", barHeight)
            .attr("width", function (d) {
                return scale(d[yCol[0]] / d[yCol[1]])
            })
            .attr("rx", 5)
            .attr("ry", 5)
            .style("fill", "#5bc0de");

        am.svg.selectAll("g")
            .data(data)
            .enter()
            .append("text")
            .attr("x", am.width - (4 * xVal))
            .attr("y", function (d, i) {
                return barHeight + i * spacing
            })
            .attr("height", barHeight)
            .text(function (d) {
                return Math.round((d[yCol[0]] / d[yCol[1]]) * 100) + "%"
            })
        am.svg.selectAll("g")
            .data(data)
            .enter()
            .append("text")
            .attr("x", xVal)
            .attr("y", function (d, i) {
                return barHeight + i * spacing
            })
            .attr("height", barHeight)
            .text(function (d) {
                return d[xCol]
            })
    }

    function generateTotalCards(elem, data, xCol, yCol) {
        data.forEach(function (d) {
            $(elem).append(
                '<div class="card mb-3 shadow-lg">' +
                '<div class="card-body">' +
                '<div class="text-muted small">' + d['name'] + '</div>' +
                '<div class="row">' +
                '<div class="col">' +
                '<div class="text-large" style="text-align:center">' +
                d['current_value'] + '</div>' +
                '</div>' +
                '</div>' +
                '</div>' +
                '<div class="card-footer">' +
                '<p class="mb-0">' +
                '<span class="text-muted small text-danger mr-2">' +
                '<i class="mdi mdi-arrow-up-bold"></i>' +
                (d['change'] * 100).toFixed(2) + '%</span>' +
                '<span class="text-nowrap text-muted small">' +
                d['msg'] + '</span>' +
                '</p>' +
                '</div>' +
                '</div>'
            )
        });
    }

    function getDownloadProgressForRadial(tableName, chart, downloadingProgress,
                                          procId = null, forceReturn = true,
                                          xCol = null, yCol = null,
                                          createVisualFunction = null,
                                          filterDict = null, addSelect = null,
                                          elem = null, task = null,
                                          oldHtml = null, clickElem = null) {
        downloadingProgress = setInterval(function () {
            $.post('/get_task_progress',
                {
                    object_type: "{{ title }}",
                    object_name: "{{ object_name }}",
                    object_level: "{{ edit_name }}",
                    task_name: tableName,
                    object_id: procId,
                    task: task
                }).done(function (data, status) {
                    let newPercent = data['percent'];
                    chart.update(parseInt(newPercent))
                    if (!forceReturn && 'data' in data) {
                        getMetricsComplete(chart, data['data'], xCol, yCol,
                            createVisualFunction, filterDict, addSelect, elem);
                        turnOffRadialProgress(elem, downloadingProgress, oldHtml, clickElem);
                    }
            });
        }, 10000);
        return downloadingProgress
    }

    function getMetricsComplete(chart, data, xCol, yCol, createVisualFunction,
        filterDict, addSelect, elem) {
        chart.update(100);
        if (Array.isArray(data) && data.length) {
            yCol = (yCol.includes('kpi')) ? (
                Object.keys(data[0]).filter(function (e) {
                    return e !== 'index' && e !== xCol
                })) : yCol
            createVisualFunction(elem, data, xCol, yCol, filterDict);
            if (addSelect) {
                addSelectOptions(data, xCol)
            }
        }
    }

    function turnOffRadialProgress(elem, downloadingProgress, oldHtml, clickElem) {
        $(elem + 'Progress').remove()
        clearInterval(downloadingProgress);
        if (oldHtml) {
            $(clickElem).prop("disabled", false);
            $(clickElem).html(oldHtml);
            unanimateBar();
        }
    }

    function getMetrics(elem, createVisualFunction, xCol, yCol,
                        filterDict = null, parentClass = "", parentHeight = 250,
                        clickElem = null, oldHtml = null, addSelect = false,
                        dashboardId = null, vendorKey = null, procId = null,
                        forceReturn = true ) {
        if (filterDict) {
            $(elem).parent().html(
                '<div id="' + elem.substring(1) +
                'Progress" class=\'widget\'></div>\n' +
                '<div id="' + elem.substring(1) + '" ' +
                'class="' + parentClass + '" ' +
                'style="height:' + parentHeight + 'px;"></div>\n'
            )
        }
        $.ajax({
            type: "POST",
            url: "/get_metrics",
            data: {
                object_name: "{{ object_name }}",
                object_type: "{{ title }}",
                object_level: "{{ edit_name }}",
                elem: elem,
                x_col: xCol,
                y_col: yCol.join('|'),
                filter_dict: JSON.stringify(filterDict),
                dashboard_id: dashboardId,
                vendor_key: vendorKey,
                object_id: procId,
                force_return: forceReturn
            },
        }).done(function (data, status) {
            console.log(data)
            console.log(status)
            if (forceReturn) {
                getMetricsComplete(chart, data, xCol, yCol,
                    createVisualFunction, filterDict, addSelect, elem)
            }
            else {
                downloadingProgress = getDownloadProgressForRadial('OutputData',
                    chart, downloadingProgress, procId, forceReturn, xCol, yCol,
                    createVisualFunction, filterDict, addSelect, elem, data['task'],
                    oldHtml, clickElem)
            }
        }).fail(function (jqXHR, textStatus) {
            console.log('fail:' + jqXHR);
            console.log("Request failed: " + textStatus);
        }).always(function () {
            if (forceReturn) {
                turnOffRadialProgress(elem, downloadingProgress, oldHtml, clickElem);
            }
        });
        let chart = radialProgress(elem + 'Progress')
        let downloadingProgress = null
        if (forceReturn) {
            downloadingProgress = getDownloadProgressForRadial('OutputData',
                chart, downloadingProgress, procId, forceReturn, xCol, yCol,
                createVisualFunction, filterDict, addSelect, elem)
        }
    }

    function radialProgress(selector) {
        const parent = d3.select(selector)
        const size = parent.node().getBoundingClientRect()
        const svg = parent.append('svg')
            .attr('width', size.width)
            .attr('height', size.height);
        const outerRadius = Math.min(size.width, size.height) * 0.45;
        const thickness = 10;
        let value = 0;

        const mainArc = d3.arc()
            .startAngle(0)
            .endAngle(Math.PI * 2)
            .innerRadius(outerRadius - thickness)
            .outerRadius(outerRadius)

        svg.append("path")
            .attr('class', 'radial-progress-bar-bg')
            .attr('transform', `translate(${size.width / 2},${size.height / 2})`)
            .attr('d', mainArc())

        const mainArcPath = svg.append("path")
            .attr('class', 'radial-progress-bar')
            .attr('transform', `translate(${size.width / 2},${size.height / 2})`)

        svg.append("circle")
            .attr('class', 'radial-progress-bar')
            .attr('transform', `translate(${size.width / 2},${size.height / 2 - outerRadius + thickness / 2})`)
            .attr('width', thickness)
            .attr('height', thickness)
            .attr('r', thickness / 2)

        const end = svg.append("circle")
            .attr('class', 'radial-progress-bar')
            .attr('transform', `translate(${size.width / 2},${size.height / 2 - outerRadius + thickness / 2})`)
            .attr('width', thickness)
            .attr('height', thickness)
            .attr('r', thickness / 2)

        let percentLabel = svg.append("text")
            .attr('class', 'progress-label')
            .attr('transform', `translate(${size.width / 2},${size.height / 2})`)
            .text('0%')

        return {
            update: function (progressPercent) {
                const startValue = value
                const startAngle = Math.PI * startValue / 50
                const angleDiff = Math.PI * progressPercent / 50 - startAngle;
                const startAngleDeg = startAngle / Math.PI * 180
                const angleDiffDeg = angleDiff / Math.PI * 180
                const transitionDuration = 1500

                mainArcPath.transition().duration(transitionDuration).attrTween('d', function () {
                    return function (t) {
                        mainArc.endAngle(startAngle + angleDiff * t)
                        return mainArc();
                    }
                })
                end.transition().duration(transitionDuration).attrTween('transform', function () {
                    return function (t) {
                        return `translate(${size.width / 2},${size.height / 2})` +
                            `rotate(${(startAngleDeg + angleDiffDeg * t)})` +
                            `translate(0,-${outerRadius - thickness / 2})`
                    }
                })
                percentLabel.transition().duration(transitionDuration).tween('bla', function () {
                    return function (t) {
                        percentLabel.text(Math.round(startValue + (progressPercent - startValue) * t));
                    }
                })
                value = progressPercent
            }
        }
    }


    function addSelectOptions(data, xCol, selectDiv=false) {
        let i = 0;
        let newData = $.map(data, function (obj) {
            obj['text'] = obj['text'] || obj[xCol];
            obj['id'] = obj['text'] || obj[xCol];
            obj['value'] = obj['text'] || obj[xCol];
            i++;
            return obj;
        });
        let elem = selectDiv ? selectDiv : "#" + xCol + "Select"
        let selectizeElem = $(elem)[0].selectize
        selectizeElem.load(function(callback) {
            callback(newData);
        });
    }

    $(document).ready(function () {
        $('#chart_type').on('change', function (e) {
            let selectedText = this.options[e.target.selectedIndex].text;
            let dimensionsJquery = '#dimensions';
            if ((selectedText === 'Area') || (selectedText === 'Line')) {
                $(dimensionsJquery).val('eventdate').trigger('change');
                $(dimensionsJquery).prop("disabled", true);
            } else {
                $(dimensionsJquery).prop("disabled", false);
            }
        });
        $('select[id$="filter_col"]').on('change', function (e) {
            let selectedText = this.options[e.target.selectedIndex].text;
            let filterNum = this.id.replace(
                'static_filters-', '').replace('-filter_col', '')
            let elemId = '#static_filters-' + filterNum + '-filter_val'
            $(elemId).empty();
            $(elemId).parent().hide()
            $(elemId).parent().parent().append(
                '<div><div id="loadingBtn"></div></div>')
            loadingBtn('#loadingBtn', '')
            $.ajax({
                type: "POST",
                url: "/get_metrics",
                data: {
                    object_name: "{{ object_name }}",
                    object_type: "{{ title }}",
                    object_level: "{{ edit_name }}",
                    elem: elemId,
                    x_col: selectedText,
                    y_col: ['impressions'].join('|'),
                },
            }).done(function (data, status) {
                $(elemId).parent().show()
                $('#loadingBtn').remove()
                addSelectOptions(data, selectedText, elemId)
            }).fail(function (jqXHR, textStatus) {
                console.log("Request failed: " + textStatus);
            }).always(function () {

            });
        });
    });
</script>