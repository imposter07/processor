<style id="customSvgStyles">
    .widget {
        height: 25vh;
        width: 175px;
        margin-left: auto;
        margin-right: auto;
    }

    .overlay {
        fill: none;
        pointer-events: all;
    }

    .radial-progress-bar {
        fill: #ddd;
        margin-left: auto;
        margin-right: auto;
        margin-top: auto;
    }

    .radial-progress-bar-bg {
        fill: #3f3f3f;
    }

    .progress-label {
        fill: #aaa;
        font-family: 'Open Sans', sans-serif;
        font-size: 15px;
        text-anchor: middle;
        dominant-baseline: central;
    }

    .outer {
        overflow: auto;
    }

    .bubble circle {
        stroke-width: 2px;
        stroke: white;
        opacity: 0.4;
    }

    .bubble:hover circle {
        stroke: black;
        opacity: 1;
    }

    .bubble-label {
        alignment-baseline: central;
        paint-order: stroke;
        stroke: white;
        stroke-width: 3px;
        font-weight: 600;
    }
</style>

<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/holtzy/D3-graph-gallery@master/LIB/d3-scale-radial.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
    function autoMargin(elem, maxHeight, lMargin, bMargin, dataLength = 1,
                        dataLengthY = 1, equalSides = false) {
        const parent = d3.select(elem);
        const size = parent.node().getBoundingClientRect()
        if (equalSides) {
            maxHeight = size.width;
        }
        let margin = {top: 10, right: lMargin, bottom: bMargin, left: lMargin},
            width = (size.width - margin.left - margin.right) * dataLength,
            height = (maxHeight - margin.top - margin.bottom) * dataLengthY;
        let svgHeight = height + margin.top + margin.bottom
        let svg = parent
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", svgHeight)
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");
        return {margin: margin, width: width, height: height, svg: svg}
    }

    function generateSelect(elem, allGroup, selectElem = 'Select',
                            defaultVal=0) {
        let buttonSelector = elem + selectElem;
        let elemToAdd = `
            <select id="${buttonSelector}" class="form-control form-control-sm">
            </select>`;
        $(buttonSelector).html(elemToAdd);
        d3.select(buttonSelector)
            .selectAll('myOptions')
            .data(allGroup)
            .enter()
            .append('option')
            .text(function (d) {
                return d;
            }) // text showed in the menu
            .attr("value", function (d) {
                return d;
            }) // corresponding value returned by the button
        allGroup = allGroup.map(x => {
            return ({text: x});
        });
        addSelectOptions(allGroup, '', buttonSelector, elem.replace('#', ''),
            defaultVal);
    }

    function wrapText(text, width) {
        text.each(function () {
            var text = d3.select(this),
                words = text.text().split(/[ _]+/).reverse(),
                word,
                line = [],
                lineNumber = 0,
                lineHeight = 1.1, // ems
                y = text.attr("y"),
                dy = parseFloat(text.attr("dy")),
                tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(" "));
                if (tspan.node().getComputedTextLength() > width) {
                    line.pop();
                    tspan.text(line.join(" "));
                    line = [word];
                    tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                }
            }
        });
    }

    function getUnits(col, precision=',.2f') {
        let costPer = 'CP';
        let units = {
            [costPer]: '$',
            'Net Cost Final': '$',
            'CTR': '%',
            'VTR': '%',
            'VCR': '%',
            'eventdate': null
        };
        if (col.startsWith(costPer)) {
            return units[costPer] + precision
        }
        if (col in units) {
            if (units[col]) {
                return units[col] + precision
            }
            else {
                return units[col]
            }
        }
        return precision
    }

    function generateY1Axis(data, svg, xAxisType, yAxisType, width, height,
                          xCol, yCol, timeX = null, y1AxisType=null, y1Col=null) {
        let y1Unit = getUnits(y1Col);
        let y1Scale = y1AxisType
            .domain([0, d3.max(data, function (d) {
                return +d[y1Col];
            })])
            .range([height, 0]);
        let y1Axis = d3.axisRight(y1Scale);
        svg.append("g")
            .attr('class', 'y1axis')
            .attr("transform", "translate(" + width + " ,0)")
            .call(y1Axis)
            .call(y1Axis.ticks(null, y1Unit))
        return {y1Scale: y1Scale, y1Axis: y1Axis}
    }

    function generateAxis(data, svg, xAxisType, yAxisType, width, height,
                          xCol, yCol, timeX = null, y1AxisType=null, y1Col=null,
                          domainX = null, domainY = null, centerAxis = false) {
        let xUnit = getUnits(xCol[0]);
        let yUnit = getUnits(yCol);

        let xDomain = function () {
            if (domainX) {
                return domainX;
            } else if (timeX) {
                return d3.extent(data, function (d) {
                    return d[xCol];
                })
            } else {
                return data.map(function (d) {
                    return d[xCol];
                })
            }
        }
        let yDomain = function () {
            if (domainY) {
                return domainY;
            } else {
                return [0, d3.max(data, function (d) {
                    return +d[yCol];
                })]
            }
        }
        let x = xAxisType
            .domain(xDomain())
            .range([0, width])
        if (!timeX && x.name === 'i') {
            x.padding(1)
        }
        let xAxis = d3.axisBottom(x)
        let transHeight = height;
        let transWidth = 0;
        if (centerAxis) {
            transHeight = 0.5*height;
            transWidth = 0.5*width;
        }
        svg.append("g")
            .attr("transform", "translate(0," + transHeight + ")")
            .attr('class', 'xaxis')
            .call(xAxis)
            .call(xAxis.ticks(null, xUnit));
        if (!timeX && x.name === 'i') {
            svg.selectAll('.xaxis')
                .selectAll(".tick text")
                .call(wrapText, x.bandwidth());
        }

        let yScale = yAxisType
            .domain(yDomain())
            .range([height, 0]);
        let yAxis = d3.axisLeft(yScale);
        svg.append("g")
            .attr("transform", "translate(" + transWidth + ", 0)")
            .attr('class', 'yaxis')
            .call(yAxis)
            .call(yAxis.ticks(null, yUnit));

        let y1Props = {};
        if (y1Col) {
            y1Props = generateY1Axis(data, svg, xAxisType, yAxisType, width, height,
                          xCol, yCol, timeX, y1AxisType, y1Col)
        }
        return {...{x: x, yScale: yScale, yAxis: yAxis, xAxis: xAxis}, ...y1Props}
    }

    function getColorPal(allGroup) {
        let myColor = d3.scaleOrdinal()
            .domain(allGroup)
            .range(d3.schemeTableau10);
        return myColor
    }

    function sortData(data, col) {
        return data.sort((a, b) => b[col] - a[col])
    }

    function updateYAxis(axes, data, svg, selectedVar, scale=null, axis=null,
                         axisSelector=".yaxis") {
        axis = (axis) ? axis :  axes.yAxis;
        scale = (scale) ? scale :  axes.yScale;
        let yUnits = getUnits(selectedVar)
        scale.domain([0, d3.max(data, function (d) {
            return +d[selectedVar]
        })]);
        svg.selectAll(axisSelector)
            .transition().duration(500)
            .call(axis)
            .call(axis.ticks(null, yUnits))
    }

    function addToolTip(svg, am, axes, data, xCol, selectedVar, myColor, timeX,
                        scale=null, selectedVar1=null, scale1=null) {
        scale = (scale) ? scale : axes.yScale;
        scale1 = (scale1) ? scale1 : axes.yScale;
        let dateFormatter = d3.timeFormat("%m/%d/%y");
        let formatValue = d3.format(getUnits(selectedVar, ',.4f'));
        let focus = svg.append("g")
            .attr("class", "focus");
        let focus1 = svg.append("g")
            .attr("class", "focus1");

        focus.append("circle")
            .attr("r", 5)
            .attr("fill", function (d) {
                return myColor(selectedVar)
            });

        focus.append("div")
            .style("opacity", 0)
            .attr("class", "tooltip")
            .style("background-color", "white")
            .style("border", "solid")
            .style("border-width", "2px")
            .style("border-radius", "5px")
            .style("padding", "5px");

        let yPos = 18;
        focus.append("text")
            .attr("class", "tooltip-y")
            .attr("x", 18)
            .attr("y", -2);
        if (selectedVar1) {
            focus1.append("circle")
                .attr("r", 5)
                .attr("fill", function (d) {
                    return myColor(selectedVar1)
                });
            focus.append("text")
                .attr("class", "tooltip-y1")
                .attr("x", 18)
                .attr("y", yPos);
            yPos += 20;
        }
        focus.append("text")
            .attr("class", "tooltip-x")
            .attr("x", 18)
            .attr("y", yPos);


        svg.append("rect")
            .attr("class", "overlay")
            .attr("width", am.width)
            .attr("height", am.height)
            .on("mouseover", function () {
                focus.attr("display", null);
                focus.attr("fill-opacity", .7)
                if (selectedVar1) {
                    focus1.attr("display", null);
                    focus1.attr("fill-opacity", .7);
                }
            })
            .on("mouseout", function () {
                focus.attr("display", "none");
                focus.attr("fill-opacity", .3);
                if (selectedVar1) {
                    focus1.attr("display", "none");
                    focus1.attr("fill-opacity", .3);
                }
            })
            .on("mousemove", mousemove);
        let bisectDate = d3.bisector(function (d) {
            return d[xCol];
        }).left

        function mousemove() {
            let dGet = function (currentThis) {
                if (timeX) {
                    let x0 = axes.x.invert(d3.mouse(currentThis)[0])
                    let i = bisectDate(data, x0, 1)
                    let d0 = data[i - 1]
                    let d1 = data[i];
                    return x0 - d0[xCol] > d1[xCol] - x0 ? d1 : d0
                } else {
                    let mx = d3.mouse(currentThis)[0] // x position of cursor
                    let idx = Math.round((mx / axes.x.step()) - axes.x.padding())
                    return data[idx]
                }
            }
            let d = dGet(this)
            let xColVal = (timeX) ? dateFormatter(d[xCol]) : d[xCol]
            focus.attr("transform", "translate(" + axes.x(d[xCol]) + "," + scale(d[selectedVar]) + ")");
            focus.select(".tooltip-y").text(selectedVar + ": " + formatValue(d[selectedVar]));
            if (selectedVar1) {
                let formatValue1 = d3.format(getUnits(selectedVar1, '.4f'));
                focus1.attr("transform", "translate(" + axes.x(d[xCol]) + "," + scale1(d[selectedVar1]) + ")");
                focus.select(".tooltip-y1").text(selectedVar1 + ": " + formatValue1(d[selectedVar1]));
            }
            focus.select(".tooltip-x").text(xCol + ": " + xColVal);
            focus.style("left", (d3.mouse(this)[0] + 70) + "px");
            focus.style("top", (d3.mouse(this)[1]) + "px");
            focus.style("margin", "5px");
            const position = d3.mouse(svg.node());
            if (position[0] > (svg.node().parentNode.width.baseVal.value/2)) {
                focus.style("text-anchor", "end");
                focus.selectAll("text").each(function(d, i) {
                    d3.select(this).attr('x', '-18');
                });
             } else {
                focus.style("text-anchor", "start");
                focus.selectAll("text").each(function(d, i) {
                    d3.select(this).attr('x', '18');
                });
             }
        }
    }

    function getAreaGenerator(axes, xCol, selectedVar) {
        return d3.area()
            .x(function (d) {
                return axes.x(d[xCol])
            })
            .y0(axes.yScale(0))
            .y1(function (d) {
                return axes.yScale(d[selectedVar])
            })
            .curve(d3.curveMonotoneX)
    }

    function getLineGenerator(axes, xCol, selectedVar, scale) {
        return d3.line()
            .x(function (d) {
                return axes.x(d[xCol])
            })
            .y(function (d) {
                return scale(d[selectedVar])
            })
            .curve(d3.curveMonotoneX)
    }

    function addClipBrush(svg, am, idleTimeout, idled, axes, u, xCol, selectedVar) {
        // Add brushing
        var clip = svg.append("defs").append("svg:clipPath")
            .attr("id", "clip")
            .append("svg:rect")
            .attr("width", am.width)
            .attr("height", am.height)
            .attr("x", 0)
            .attr("y", 0);

        // Add brushing
        var brush = d3.brushX()                   // Add the brush feature using the d3.brush function
            .extent([[0, 0], [am.width, am.height]])  // initialise the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
            .on("end", updateChartFromClipBrush)               // Each time the brush selection changes, trigger the 'updateChart' function

        function updateChartFromClipBrush() {

            // What are the selected boundaries?
            let extent = d3.event.selection
            // If no selection, back to initial coordinate. Otherwise, update X axis domain
            if (!extent) {
                if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // This allows to wait a little bit
                axes.x.domain([4, 8])
            } else {
                axes.x.domain([axes.x.invert(extent[0]), axes.x.invert(extent[1])])
                u.select(".brush").call(brush.move, null) // This remove the grey brush area as soon as the selection has been done
            }
            // Update axis and area position
            svg.selectAll(".xaxis")
                .transition().duration(500)
                .call(axes.xAxis)
            let areaGenerator = getAreaGenerator(axes, xCol, selectedVar)
            u
                .select('.lineTest')
                .transition()
                .duration(1000)
                .attr("d", areaGenerator)
        }

        return {clip: clip, brush: brush}
    }

    function groupData() {
        var nested_data = d3.nest()
            .key(function (d) {
                return d.Clicked;
            })
            .key(function (d) {
                return d.Campaign
            })
            .rollup(function (values) {
                return values.length;
            })
            .entries(data);
    }

    function generateHistogram() {
        // set the dimensions and margins of the graph
        var margin = {top: 10, right: 30, bottom: 30, left: 40},
            width = 460 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg = d3.select("#my_dataviz")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");

        // get the data
        d3.json("/get_metrics").then(function (data) {

            // X axis: scale and draw:
            var x = d3.scaleLinear()
                .domain([0, 1000])     // can use this instead of 1000 to have the max of data: d3.max(data, function(d) { return +d.price })
                .range([0, width]);
            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // set the parameters for the histogram
            var histogram = d3.histogram()
                .value(function (d) {
                    return d.price;
                })   // I need to give the vector of value
                .domain(x.domain())  // then the domain of the graphic
                .thresholds(x.ticks(70)); // then the numbers of bins

            // And apply this function to data to get the bins
            var bins = histogram(data);

            // Y axis: scale and draw:
            var y = d3.scaleLinear()
                .range([height, 0]);
            y.domain([0, d3.max(bins, function (d) {
                return d.length;
            })]);   // d3.hist has to be called before the Y axis obviously
            svg.append("g")
                .call(d3.axisLeft(y));

            // append the bar rectangles to the svg element
            svg.selectAll("rect")
                .data(bins)
                .enter()
                .append("rect")
                .attr("x", 1)
                .attr("transform", function (d) {
                    return "translate(" + x(d.x0) + "," + y(d.length) + ")";
                })
                .attr("width", function (d) {
                    return x(d.x1) - x(d.x0) - 1;
                })
                .attr("height", function (d) {
                    return height - y(d.length);
                })
                .style("fill", "#69b3a2")

        });
    }

    function generateLineChart(elem, data, xCol, yCol) {
        let am = autoMargin(elem, 500, 60, 30);
        let svg = am.svg
        let parseDate = d3.timeParse("%Y-%m-%d");
        data.forEach(function (d) {
            d[xCol] = parseDate(d[xCol]);
        });
        generateSelect(elem, yCol)
        // A color scale: one color for each group
        let myColor = getColorPal(yCol)
        let axes = generateAxis(
            data, svg, d3.scaleTime(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], true
        )
        // A function that update the chart
        function update(selectedVar) {
            updateYAxis(axes, data, svg, selectedVar)
            let lineGenerator = getLineGenerator(axes, xCol, selectedVar,
                axes.yScale)
            let u = svg.selectAll(".lineTest")
                .data([data])
            u
                .enter()
                .append("path")
                .attr("class", "lineTest")
                .merge(u)
                .transition()
                .duration(1000)
                .attr("d", lineGenerator)
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 4)
                .attr("fill", "none")
            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor, true)
        }
        // When the button is changed, run the updateChart function
        d3.select(elem + 'Select').on("change", function (d) {
            // recover the option that has been chosen
            let selectedOption = d3.select(this).property("value")
            // run the updateChart function with this selected option
            update(selectedOption)
        })
        update(yCol[0])
    }

    function generateAreaChart(elem, data, xCol, yCol, filterCols) {
        elem = `#${elem}`;
        let am = autoMargin(elem, 250, 60, 30);
        let svg = am.svg
        let parseDate = d3.timeParse("%Y-%m-%d");
        data.forEach(function (d) {
            d[xCol] = parseDate(d[xCol]);
        });
        generateSelect(elem, yCol)
        // generateSelect(elem, filterCols, 'SelectDimension')
        // A color scale: one color for each group
        let myColor = getColorPal(yCol)
        let axes = generateAxis(
            data, svg, d3.scaleTime(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], true
        )

        // A function that update the chart
        function update(selectedVar, selectedDim = null) {
            updateYAxis(axes, data, svg, selectedVar)
            let areaGenerator = getAreaGenerator(axes, xCol, selectedVar)
            let u = svg.selectAll(".lineTest")
                .data([data])
                .attr("clip-path", "url(#clip)")
            u
                .enter()
                .append("path")
                .attr("class", "lineTest")
                .merge(u)
                .transition()
                .duration(1000)
                .attr("d", areaGenerator)
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 1)
                .attr("fill-opacity", .3)
                .attr("fill", function (d) {
                    return myColor(selectedVar)
                })
            var idleTimeout = null

            function idled() {
                idleTimeout = null;
            }

            let clipBrush = addClipBrush(svg, am, idleTimeout,
                idled, axes, u, xCol, selectedVar)
            u
                .enter()
                .append("g")
                .attr("class", "brush")
                .call(clipBrush.brush);
            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor, true)
        }

        $(elem + 'Select').on("change", function (e) {
            let selectedOption = $(e.currentTarget).val();
            update(selectedOption)
        })

        // If user double click, reinitialize the chart
        svg.on("dblclick", function () {
            axes.x.domain(d3.extent(data, function (d) {
                return d[xCol];
            }))
            svg.selectAll(".xaxis")
                .transition().duration(500)
                .call(axes.xAxis)
            update(yCol[0])
        });
        update(yCol[0])
    }


    function generateDualLineChart(elem, data, xCol, yCol, filterCols) {
        elem = `#${elem}`;
        let am = autoMargin(elem, 400, 60, 30);
        let svg = am.svg;
        let parseDate = d3.timeParse("%Y-%m-%d");
        data.forEach(function (d) {
            d[xCol] = parseDate(d[xCol]);
        });
        generateSelect(elem, yCol, "Select0");
        generateSelect(elem, yCol, "Select1", 1);
        // generateSelect(elem, filterCols, 'SelectDimension')
        // A color scale: one color for each group
        let myColor = getColorPal(yCol);
        let axes = generateAxis(
            data, svg, d3.scaleTime(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], true, d3.scaleLinear(), yCol[1]
        );

        // A function that update the chart
        function update(selectedVar, selectedDim = null, yAxis, line, selectedVar1) {
            let scale = (yAxis === '.yaxis') ? axes.yScale :  axes.y1Scale;
            let scale1 = (yAxis === '.yaxis') ? axes.y1Scale :  axes.yScale;
            let axis = (yAxis === '.yaxis') ? axes.yAxis : axes.y1Axis;
            let fill = (yAxis === '.yaxis') ? .3 : 0;
            updateYAxis(axes, data, svg, selectedVar, scale, axis, yAxis);
            let lineGenerator = (yAxis === '.yaxis') ?
                getAreaGenerator(axes, xCol, selectedVar, scale) :
                getLineGenerator(axes, xCol, selectedVar, scale);
            let u = svg.selectAll(''.concat(".", line))
                .data([data])
                .attr("clip-path", "url(#clip)");
            u
                .enter()
                .append("path")
                .attr("class", line)
                .merge(u)
                .transition()
                .duration(1000)
                .attr("d", lineGenerator)
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 3)
                .attr("fill-opacity", fill)
                .attr("fill", function (d) {
                    return myColor(selectedVar)
                })
            d3.selection.prototype.last = function() {
              var last = this.size() - 1;
              return d3.select(this['_groups'][0][last]);
            };
            svg.call(g => g.selectAll(yAxis).selectAll('.tick > text')
                  .attr('fill', "currentColor"));
            svg.call(g => g.selectAll(yAxis).selectAll('.tick > text').last()
                  .attr('fill', myColor(selectedVar)));
            var idleTimeout = null

            function idled() {
                idleTimeout = null;
            }

            let clipBrush = addClipBrush(svg, am, idleTimeout,
                idled, axes, u, xCol, selectedVar);
            u
                .enter()
                .append("g")
                .attr("class", "brush")
                .call(clipBrush.brush);
            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor, true,
                scale, selectedVar1, scale1)
        }

        $(elem + 'Select0').on("change", function (e) {
            let selectedOption = $(e.currentTarget).val();
            let selectedOption1 = $(elem + 'Select1').val();
            let color = myColor(selectedOption);
            let colorOpacity = hexToRgb(color);
            colorOpacity = colorOpacity.replace('1)', '.3)');
            let style = ('border-color: ' + color + ' !important;' +
                'background-color: ' + colorOpacity);
            update(selectedOption, null, ".yaxis", "line0", selectedOption1);
            update(selectedOption1, null, ".y1axis", "line1", selectedOption);
            $(elem + 'Select0Key').attr('style', style);
        });
        $(elem + "Select1").on("change", function (e) {
            let selectedOption1 = $(e.currentTarget).val();
            let selectedOption = $(elem + 'Select0').val();
            update(selectedOption, null, ".yaxis", "line0", selectedOption1);
            update(selectedOption1, null, ".y1axis", "line1", selectedOption);
            $(elem + 'Select1Key').css('background-color',
                myColor(selectedOption1))
        });

        // If user double click, reinitialize the chart
        svg.on("dblclick", function () {
            axes.x.domain(d3.extent(data, function (d) {
                return d[xCol];
            }))
            svg.selectAll(".xaxis")
                .transition().duration(500)
                .call(axes.xAxis);
            update(yCol[0], null, ".yaxis", "line0", yCol[1]);
            update(yCol[1], null, ".y1axis", "line1", yCol[0])
        });
        update(yCol[0], null, ".yaxis", "line0", yCol[1]);
        update(yCol[1], null, ".y1axis", "line1", yCol[0]);
        let color = myColor(yCol[0]);
        let colorOpacity = hexToRgb(color);
        colorOpacity = colorOpacity.replace('1)', '.3)');
        let style = ('border-color: ' + color + ' !important;' +
            'background-color: ' + colorOpacity);
        $(elem + 'Select0Key').attr('style', style);
        $(elem + 'Select1Key').css('background-color',
            myColor(yCol[1]));
    }

    function generateLollipopChart(elem, data, xCol, yCol) {
        elem = `#${elem}`;
        data = sortData(data, yCol[0])
        let dataLength = (data.length < 20) ? 1 : data.length / 20
        let am = autoMargin(elem, 250, 60, 30, dataLength);
        let svg = am.svg
        generateSelect(elem, yCol)
        let myColor = getColorPal(yCol)
        let axes = generateAxis(
            data, svg, d3.scaleBand(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], false
        )

        function update(selectedVar) {
            updateYAxis(axes, data, svg, selectedVar);
            // variable u: map data to existing circle
            var j = svg.selectAll(".myLine")
                .data(data)
            // update lines
            j
                .enter()
                .append("line")
                .attr("class", "myLine")
                .merge(j)
                .transition()
                .duration(1000)
                .attr("x1", function (d) {
                    return axes.x(d[xCol]);
                })
                .attr("x2", function (d) {
                    return axes.x(d[xCol]);
                })
                .attr("y1", axes.yScale(0))
                .attr("y2", function (d) {
                    return axes.yScale(d[selectedVar]);
                })
                .attr("stroke", "grey")


            // variable u: map data to existing circle
            var u = svg.selectAll("circle")
                .data(data)
            // update bars
            u
                .enter()
                .append("circle")
                .merge(u)
                .transition()
                .duration(1000)
                .attr("cx", function (d) {
                    return axes.x(d[xCol]);
                })
                .attr("cy", function (d) {
                    return axes.yScale(d[selectedVar]);
                })
                .attr("r", 8)
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 1)
                .attr("fill", function (d) {
                    return myColor(selectedVar)
                })
                .attr("fill-opacity", .3)

            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor)
        }

        $(elem + 'Select').on("change", function (e) {
            let selectedOption = $(e.currentTarget).val();
            update(selectedOption)
        })

        update(yCol[0])
    }

    function generateMiniChart(elem, axes, am) {

        var svg = d3.select("svg"),
            margin2 = {top: 430, right: 20, bottom: 30, left: 40},
            width = +svg.attr("width") - axes.margin.left - axes.margin.right,
            height2 = +svg.attr("height") - margin2.top - margin2.bottom;
        var x2 = d3.scaleTime().range([0, width]),
            y2 = d3.scaleLinear().range([height2, 0]);

        var xAxis2 = d3.axisBottom(x2)

        var brush = d3.brushX()
            .extent([[0, 0], [width, height2]])
            .on("brush end", brushed);

        var zoom = d3.zoom()
            .scaleExtent([1, Infinity])
            .translateExtent([[0, 0], [width, am.height]])
            .extent([[0, 0], [width, am.height]])
            .on("zoom", zoomed);

        var area2 = d3.area()
            .curve(d3.curveMonotoneX)
            .x(function (d) {
                return x2(d[xCol]);
            })
            .y0(height2)
            .y1(function (d) {
                return y2(d[selectedVar]);
            });

        svg.append("defs").append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("width", width)
            .attr("height", height);

        var focus = svg.append("g")
            .attr("class", "focus")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var context = svg.append("g")
            .attr("class", "context")
            .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

        function brushed() {
            if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
            var s = d3.event.selection || x2.range();
            x.domain(s.map(x2.invert, x2));
            focus.select(".area").attr("d", area);
            focus.select(".axis--x").call(xAxis);
            svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
                .scale(width / (s[1] - s[0]))
                .translate(-s[0], 0));
        }

        function zoomed() {
            if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
            var t = d3.event.transform;
            x.domain(t.rescaleX(x2).domain());
            focus.select(".area").attr("d", area);
            focus.select(".axis--x").call(xAxis);
            context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
        }

        function type(d) {
            d.date = parseDate(d.date);
            d.price = +d.price;
            return d;
        }
    }

    function generateBubbleChart(elem, data, xCol, yCol, labelCol,
                                 domainX = null, domainY = null,
                                 centerAxis = false) {
        const elemId = elem.replace('#', '');
        document.getElementById(elemId).innerHTML = '';
        let am = autoMargin(elem, 768, 60, 60, 1, 1, true);
        let svg = am.svg;
        let myColor = getColorPal(yCol);
        let axes = generateAxis(
            data, svg, d3.scaleLinear(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], false, null, null, domainX, domainY, centerAxis
        );
        svg.append("g")
            .append("text")
            .attr("transform",
                "translate(" + [am.width*0.5 + 10, 10] + ")")
            .text(yCol);
        svg.append("g")
            .append("text")
            .attr("transform",
                "translate(" + [am.width - 60, am.height*0.5 - 10] + ")")
            .text(xCol);
        let tooltip = d3.select(elem)
            .append("div")
              .style("opacity", 0)
              .attr("class", "tooltip")
              .style("background-color", "white")
              .style("border", "solid")
              .style("border-width", "2px")
              .style("border-radius", "5px")
              .style("padding", "5px");

        let showTooltip = function(d) {
            tooltip
              .transition()
              .duration(200)
            tooltip
              .style("opacity", 1)
              .style("pointer-events", "none")
              .html(xCol + ": " + d[xCol].toPrecision(2) + "<br>"
                + yCol[0] + ": " + d[yCol[0]].toPrecision(2))
              .style("left", (d3.mouse(this)[0]+50) + "px")
              .style("top", (d3.mouse(this)[1]+100) + "px")
        }

        let moveTooltip = function(d) {
            tooltip
              .style("left", (d3.mouse(this)[0]+50) + "px")
              .style("top", (d3.mouse(this)[1]+100) + "px")
        }

        let hideTooltip = function(d) {
            tooltip
              .transition()
              .duration(200)
              .style("opacity", 0)
        }

        function update(selectedVar) {
            var j = svg.selectAll("circle")
                .data(data)

            let enterElem = j
                .enter()
                .append("g")
                    .attr("class", "bubble")
                    .on("mouseover", showTooltip )
                    .on("mousemove", moveTooltip )
                    .on("mouseleave", hideTooltip );

            enterElem
                .append("circle")
                    .attr("cx", function (d) {
                        return axes.x(d[xCol]);
                    })
                    .attr("cy", function (d) {
                        return axes.yScale(d[selectedVar]);
                    })
                    .attr("r", 24)
                    .attr("fill", function (d) {
                        return myColor(selectedVar);
                    });

            enterElem
                .append("text")
                    .attr("class", "bubble-label")
                    .attr("x", function(d) {
                        return axes.x(d[xCol]);
                    })
                    .attr("y", function(d) {
                        return axes.yScale(d[selectedVar]);
                    })
                    .attr("text-anchor", "middle")
                    .text(function(d) {return d[labelCol];});
        }
        update(yCol[0]);
    }

    function generateBarChart(elem, data, xCol, yCol) {
        elem = `#${elem}`;
        elemId = elem.replace('#', '');
        document.getElementById(elemId).innerHTML='';
        data = sortData(data, yCol[0]);
        let dataLength = (data.length < 10) ? 1 : data.length / 10;
        let am = autoMargin(elem, 250, 60, 30, dataLength);
        let svg = am.svg;
        generateSelect(elem, yCol);
        // A color scale: one color for each group
        let myColor = getColorPal(yCol);
        let axes = generateAxis(
            data, svg, d3.scaleBand(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], false);

        function update(selectedVar) {
            // Add Y axis
            updateYAxis(axes, data, svg, selectedVar);
            // variable u: map data to existing circle
            var j = svg.selectAll(".bar")
                .data(data)
            // update lines
            j
                .enter()
                .append("rect")
                .attr("class", "bar")
                .merge(j)
                .transition()
                .duration(1000)
                .attr("x", function (d) {
                    return axes.x(d[xCol]);
                })
                .attr("y", function (d) {
                    return axes.yScale(d[selectedVar]);
                })
                .attr("width", 20)
                .attr("height", function (d) {
                    return am.height - axes.yScale(d[selectedVar]);
                })
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 1)
                .attr("fill", function (d) {
                    return myColor(selectedVar)
                })
                .attr("fill-opacity", .3)
            // generateMiniChart(elem)
            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor)
        }

        $(elem + 'Select').on("change", function (e) {
            let selectedOption = $(e.currentTarget).val();
            update(selectedOption)
        })

        update(yCol[0])
    }

    function generateWorldMap(elem, data, xCol, yCol) {
        let am = autoMargin(elem, 500, 0, 0);    // example data from server
    }

    function generateCircularBarplot(elem, data, xCol, yCol) {
        data = sortData(data, yCol[0])
        const parent = d3.select(elem)
        const size = parent.node().getBoundingClientRect()
        const svg = parent.append('svg')
            .attr('width', size.width)
            .attr('height', 500)
            .append("g")
            .attr("transform", "translate(" + (size.width / 2) + "," + (250) + ")");

        let innerRadius = 10;
        let outerRadius = Math.min(size.width, 250) / 2;

        var x = d3.scaleBand()
            .range([0, 2 * Math.PI])    // X axis goes from 0 to 2pi = all around the circle. If I stop at 1Pi, it will be around a half circle
            .align(0)                  // This does nothing
            .domain(data.map(function (d) {
                return d[xCol];
            })); // The domain of the X axis is the list of states.
        var y = d3.scaleRadial()
            .range([innerRadius, outerRadius])   // Domain will be define later.
            .domain([0, 100000]); // Domain of Y is from 0 to the max seen in the data

        var ybis = d3.scaleRadial()
            .range([innerRadius, 5])   // Domain will be defined later.
            .domain([0, 100000]);

        // Add the bars
        svg.append("g")
            .selectAll("path")
            .data(data)
            .enter()
            .append("path")
            .attr("fill", "#69b3a2")
            .attr("d", d3.arc()     // imagine your doing a part of a donut plot
                .innerRadius(innerRadius)
                .outerRadius(function (d) {
                    return y(d[yCol[1]] - d[yCol[0]]);
                })
                .startAngle(function (d) {
                    return x(d[xCol]);
                })
                .endAngle(function (d) {
                    return x(d[xCol]) + x.bandwidth();
                })
                .padAngle(0.01)
                .padRadius(innerRadius))

        svg.append("g")
            .selectAll("g")
            .data(data)
            .enter()
            .append("g")
            .attr("text-anchor", function (d) {
                return (x(d[xCol]) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "end" : "start";
            })
            .attr("transform", function (d) {
                return "rotate(" + ((x(d[xCol]) + x.bandwidth() / 2) * 180 / Math.PI - 90) + ")" + "translate(" + (y(d[yCol[0]]) + 10) + ",0)";
            })
            .append("text")
            .text(function (d) {
                return (d[xCol])
            })
            .attr("transform", function (d) {
                return (x(d[xCol]) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "rotate(180)" : "rotate(0)";
            })
            .style("font-size", "11px")
            .attr("alignment-baseline", "middle")
        svg.append("g")
            .selectAll("path")
            .data(data)
            .enter()
            .append("path")
            .attr("fill", "red")
            .attr("d", d3.arc()     // imagine your doing a part of a donut plot
                .innerRadius(function (d) {
                    return ybis(0)
                })
                .outerRadius(function (d) {
                    return ybis(d[yCol[0]]);
                })
                .startAngle(function (d) {
                    return x(d[xCol]);
                })
                .endAngle(function (d) {
                    return x(d[xCol]) + x.bandwidth();
                })
                .padAngle(0.01)
                .padRadius(innerRadius))
    }

    function generateProgressBars(elem, data, xCol, yCol) {
        elem = `#${elem}`;
        data.sort((a, b) => b[yCol[0]] - a[yCol[0]])
        let dataLength = (data.length < 5) ? 1 : data.length / 5
        let am = autoMargin(elem, 250, 5, 5, .9, dataLength)
        let xVal = 10
        let barHeight = 20
        let spacing = 50
        let scale = d3.scaleLinear()
            .domain([0, 1])
            .range([0, am.width]);
        am.svg.selectAll("g")
            .data(data)
            .enter()
            .append("rect")
            .attr("x", xVal)
            .attr("y", function (d, i) {
                return barHeight + i * spacing
            })
            .attr("height", barHeight)
            .attr("width", function (d) {
                return scale(scale.domain()[1])
            })
            .attr("rx", 5)
            .attr("ry", 5)
            .style("fill", "#ddd");

        am.svg.selectAll("g")
            .data(data)
            .enter()
            .append("rect")
            .attr("x", xVal)
            .attr("y", function (d, i) {
                return barHeight + i * spacing
            })
            .attr("height", barHeight)
            .attr("width", function (d) {
                return scale(d[yCol[0]] / d[yCol[1]])
            })
            .attr("rx", 5)
            .attr("ry", 5)
            .style("fill", "#5bc0de");

        am.svg.selectAll("g")
            .data(data)
            .enter()
            .append("text")
            .attr("x", am.width - (4 * xVal))
            .attr("y", function (d, i) {
                return barHeight + i * spacing
            })
            .attr("height", barHeight)
            .text(function (d) {
                return Math.round((d[yCol[0]] / d[yCol[1]]) * 100) + "%"
            })
        am.svg.selectAll("g")
            .data(data)
            .enter()
            .append("text")
            .attr("x", xVal)
            .attr("y", function (d, i) {
                return barHeight + i * spacing
            })
            .attr("height", barHeight)
            .text(function (d) {
                return d[xCol]
            })
    }

    function animateValue(obj, end, duration, displayValue) {
        let startTimestamp = null;
        const step = (timestamp) => {
            let start = Number(obj.innerHTML.replace(/[^0-9.-]+/g,""));
            if (!startTimestamp) startTimestamp = timestamp;
            const progress = Math.min((timestamp - startTimestamp) / duration, 1);
            obj.innerHTML = Math.floor(progress * (end - start) + start);
            if (progress < 1) {
                window.requestAnimationFrame(step);
            }
            else {
                obj.innerHTML = displayValue;
            }
        };
        window.requestAnimationFrame(step);
    }

    function generateTotalCards(elem, data, xCol, yCol) {
        elem = elem.replace('#', '');
        data.forEach(function (d) {
            let totalCardElem = document.getElementById('totalCard' + d['name']);
            if (totalCardElem === null) {
                let curElem = document.getElementById(elem);
                curElem.innerHTML += `
                    <div id="totalCard` + d['name'] + `" class="card mb-auto shadow-sm">
                    <div class="card-body p-3">
                    <h3 class="text-muted small">` + d['name'].toUpperCase().replace('ESTIMATED_', 'e').split('_').join(' ') + `</h3>
                    <h5 id="totalCardValue` + d['name'] + `" class="text-large" style="text-align:center">
                    ` + d['current_value'] + `</h5>
                    </div>
                    <div class="card-footer p-2 d-flex align-items-center justify-content-center">
                    <p id="totalCardChange` + d['name'] + `" class="text-muted small">
                    ` + (d['change'] * 100).toFixed(2) + `% ` + d['msg'] + ` </p>
                    </div>
                    </div>`
            }
            else {
                let changeElem = document.getElementById("totalCardValue" + d['name']);
                animateValue(changeElem, d['numeric_value'], 500, d['current_value'])
                changeElem = document.getElementById("totalCardChange" + d['name']);
                animateValue(changeElem, d['change'], 500, (d['change'] * 100).toFixed(2) + `% ` + d['msg'])
            }
        });
    }

    function generateKpiNotes(elem, data, xCol, yCol) {
        elem = elem.replace('#', '');
        document.getElementById(elem).innerHTML = `
                                    <p id="dailyMetricsNotes0"></p>
                                    <br>
                                    <p id="dailyMetricsNotes1"></p>
                                    <br>`;

        function update(selectedVar, pos) {
            let curElem = document.getElementById(elem + pos);
            if (curElem) {
                curElem.innerHTML = '';
                data.forEach(function (d) {
                    if (d['index'] === 'Trend') {
                        if (d[selectedVar]) {
                            curElem.innerText += d[selectedVar]
                        }
                    } else {
                        if (d[selectedVar]) {
                            curElem.innerHTML += `<li>` + d[selectedVar] + `</li>`
                        }
                    }
                })
            }
        }
        
        let pos0 = '0';
        let pos1 = '1';
        let selectorElem = '#' + elem.replace('Notes', '') + 'Select';
        addOnClickEvent(selectorElem + pos0, function (e) {
            let selectedOption = $(e.currentTarget).val();
            update(selectedOption, pos0)
        }, 'change', true, false);
        addOnClickEvent(selectorElem + pos1, function (e) {
            let selectedOption = $(e.currentTarget).val();
            update(selectedOption, pos1)
        }, 'change', true, false);

        update(Object.keys(data[0])[0], pos0);
        update(Object.keys(data[0])[1], pos1);
    }

    function getMetricsComplete(data, xCol, yCol, createVisualFunction,
                                filterDict, addSelect, elem) {
        if (Array.isArray(data) && data.length) {
            yCol = Object.keys(data[0]).filter(function (e) {
                return e !== 'index' && e !== xCol[0]
            });
            document.getElementById(elem).innerHTML = "";
            createVisualFunction(elem, data, xCol, yCol, filterDict);
            if (addSelect) {
                addSelectOptions(data, xCol, false, "", false)
            }
        }
    }

    function getDownloadProgressForRadial(tableName, chart, downloadingProgress,
                                          procId = null, forceReturn = false,
                                          xCol = null, yCol = null,
                                          createVisualFunction = null,
                                          filterDict = null, addSelect = null,
                                          elem = null, task = null,
                                          oldHtml = null, clickElem = null) {
        downloadingProgress = setInterval(function () {
            $.post('/get_task_progress',
                {
                    object_type: "{{ title }}",
                    object_name: "{{ object_name }}",
                    object_level: "{{ edit_name }}",
                    task_name: tableName,
                    object_id: procId,
                    task: task
                }).done(function (data, status) {
                    let newPercent = data['percent'];
                    chart.update(parseInt(newPercent))
                    if (!forceReturn && 'data' in data) {
                        getMetricsComplete(chart, data['data'], xCol, yCol,
                            createVisualFunction, filterDict, addSelect, elem);
                        turnOffRadialProgress(elem, downloadingProgress, oldHtml, clickElem);
                    }
            });
        }, 5000);
        return downloadingProgress
    }

    function turnOffRadialProgress(elem, downloadingProgress, oldHtml, clickElem) {
        $(elem + 'Progress').remove()
        clearInterval(downloadingProgress);
        if (oldHtml) {
            $(clickElem).prop("disabled", false);
            $(clickElem).html(oldHtml);
            unanimateBar();
        }
    }

    function getDataTableArgsDict(return_func='', dimensions=[], metrics = [],
                                  filter_dict = [], use_cache, proc_id) {
        const dataTableArgs = {};
        if (typeof use_cache !== 'undefined') {
            dataTableArgs['use_cache'] = true;
        }
        if (typeof proc_id !== 'undefined') {
            dataTableArgs['proc_id'] = proc_id;
        }
        dataTableArgs['return_func'] = return_func;
        dataTableArgs['dimensions'] = dimensions;
        dataTableArgs['metrics'] = metrics;
        dataTableArgs['filter_dict'] = filter_dict;
        return dataTableArgs;
    }

    function addEdit(tableID, cols, buttonID) {
        const rows = document.getElementById(tableID).getElementsByTagName('tr');
        const colIndices = [];
        for (let j = 0, col; col = rows[0].cells[j]; j++) {
            if (cols.includes(rows[0].cells[j].innerHTML)) {
              colIndices.push(j);
            }
        }
        for (let i = 0; i < colIndices.length; i++) {
            for (let j = 1, row; row = rows[j]; j++) {
                rows[j].cells[colIndices[i]].setAttribute("contenteditable", "true");
                rows[j].cells[colIndices[i]].setAttribute("spellcheck", "false");
            }
        }
        cols = cols.join("','");
        cols = "['" +  cols + "']";
        const functionString = "overWritePlannedwPacing('" + tableID + "', " + cols + ")";
        const saveElem = document.getElementById(buttonID);
        saveElem.setAttribute("onclick", functionString);
        $('td').blur(function () {
            $('#' + buttonID).removeAttr('disabled');
            $('#' + buttonID).attr("class", "btn btn-success");
        });
    }

    function overWritePlannedwPacing(tableID, cols) {
        const tableName = 'dictionaryvendorkeyPlan___Net';
        let tid = 'Pacing Table';
        let data = getTableAsArray(tid, cols);
        SendDataTable(tableName, null, '', '', data, [], 'pacingTableSaveButton');
    }

    function getProgBars(tableName, progCol, paceCol, startCol) {
        const rows = document.getElementById(tableName).getElementsByTagName('tr');
        let progColInd = 0;
        let paceColInd = 0;
        let startColInd = 0;
        for (let j = 0, col; col = rows[0].cells[j]; j++) {
            if (rows[0].cells[j].innerHTML === progCol) {
                progColInd = j;
            }
            if (rows[0].cells[j].innerHTML === paceCol) {
                paceColInd = j;
            }
            if (rows[0].cells[j].innerHTML === startCol) {
                startColInd = j;
            }
        }
        let style, backgroundColor, delv, pace, today, sd, tooltip, delvColor;
        for (let i = 1, row; row = rows[i]; i++) {
            if (window.getComputedStyle) {
                style = window.getComputedStyle(row.cells[progColInd]);
            } else {
                style = row.cells[progColInd].currentStyle;
            }
            backgroundColor = style.backgroundColor;
            row.cells[progColInd].style.height = "100%";
            row.cells[progColInd].style.border = "1px solid #dee2e6";
            row.id = "tr" + String(i - 1);
            delv = row.cells[progColInd].innerHTML;
            pace = row.cells[paceColInd].innerHTML;
            delv = delv.slice(0, -1);
            pace = pace.slice(0, -1);
            delv = parseInt(delv);
            pace = parseInt(pace);
            today = today = new Date();
            sd = new Date(row.cells[startColInd].innerHTML);
            if (pace > 100) {
                pace = 100;
            }
            tooltip = "Delivery: " + delv + "% \nExpected Delivery: "
                + pace + "%";
            getTooltip(tooltip, row.cells[progColInd]);
            if ((delv > 105) || ((delv / pace) > 1.15)) {
                delvColor = "#dc3545cc";
            } else {
                delvColor = "#0d6efdcc";
            }
            if (sd >= today && delv <= 2) {
                row.cells[progColInd].style.background = "linear-gradient(to right, " + delvColor + " 2%, "
                    + "#ffc107cc 2% 4%, "
                    + backgroundColor + " 4%)";
            } else if (sd >= today && delv > 2) {
                row.cells[progColInd].style.background = "linear-gradient(to right, #ffc107cc 2%, "
                    + delvColor + " 2% " + delv + "%, "
                    + backgroundColor + " " + delv + "%)";
            } else if (pace >= 98 && delv >= 98) {
                row.cells[progColInd].style.background = "linear-gradient(to right,  " + delvColor + " 98%, "
                    + "#ffc107cc 98%)";
            } else if (pace >= 98 && delv < 98) {
                row.cells[progColInd].style.background = "linear-gradient(to right, " + delvColor + " "
                    + delv + "%, "
                    + backgroundColor + " " + delv + "% " + "98%, "
                    + "#ffc107cc 98%)";
            } else if (pace < 98 && delv >= 98) {
                row.cells[progColInd].style.background = "linear-gradient(to right, " + delvColor + " "
                    + pace + "%, "
                    + "#ffc107cc " + pace + "% " + (pace + 2) + "%, "
                    + delvColor + " " + (pace + 2) + "%)";
            } else if (Math.abs(pace - delv) <= 2) {
                row.cells[progColInd].style.background = "linear-gradient(to right, " + delvColor + " "
                    + delv + "%, "
                    + "#ffc107cc " + delv + "% " + (delv + 2) + "%, "
                    + backgroundColor + " " + (delv + 2) + "%)";
            } else if (pace < delv) {
                row.cells[progColInd].style.background = "linear-gradient(to right, " + delvColor + " "
                    + pace + "%, "
                    + "#ffc107cc " + pace + "% " + (pace + 2) + "%, "
                    + delvColor + " " + (pace + 2) + "% " + delv + "%, "
                    + backgroundColor + " " + delv + "%)";
            } else if (pace > delv) {
                row.cells[progColInd].style.background = "linear-gradient(to right,  " + delvColor + " "
                    + delv + "%, "
                    + backgroundColor + " " + delv + "% " + pace + "%, "
                    + "#ffc107cc " + pace + "% " + (pace + 2) + "%, "
                    + backgroundColor + " " + (pace + 2) + "%)";
            }
        }
    }

    function getTooltip(content, cell){
        cell.setAttribute("class", "dropdown-item");
        cell.setAttribute("data-toggle", "hover");
        cell.setAttribute("data-placement", "bottom");
        cell.setAttribute("title", content);
        cell.style.height = "100%"
    }

    function addAccordianSetup(tableName) {
        const rows = document.getElementById(tableName).getElementsByTagName('tr');
        for (let i = 1, row; row = rows[i]; i++) {
            let expandButtonHTML = `<button class="btn btn-primary btn-sm fa-solid fa-chevron-up collapsed"
                data-target="#collapseRow` + (i-1) + `" data-toggle="collapse"
                aria-expanded="False" type="button" style="color:white">
                </button>`;
            let expandCell = rows[i].insertCell(-1);
            expandCell.innerHTML = expandButtonHTML;
        }
    }

    function hideColumn(tableName, colName) {
        const rows = document.getElementById(tableName).getElementsByTagName('tr');
        let colInd = 0;
        for (let j = 0, col; col = rows[0].cells[j]; j++) {
            if (rows[0].cells[j].innerHTML === colName) {
                colInd = j;
            }
        }
        for (let i = 0, row; row = rows[i]; i++) {
            rows[i].cells[colInd].style.display = "none";
        }
    }

    function generatePacingTable(elemID, data, xCol, yCol) {
        let elem = document.getElementById(elemID);
        elem.innerHTML += data;
        elem.style.height = "100%";
        let cols = xCol + [, 'Planned Net Cost', 'Uncapped'];
        cols = cols.split(",");
        addEdit(elemID, cols, 'pacingTableSaveButton');
        getProgBars(elemID, "Delivery", "% Through Campaign", "Start Date");
        hideColumn(elemID, "% Through Campaign");
        addAccordianSetup(elemID);
        getTable('Daily Pacing', elem.id);
        animateBar();
    }

    function addSort(tableName, bodyName) {
        const headerId = 'pacingHeader';
        const rows = document.getElementById(tableName).getElementsByTagName('tr');
        rows[0].parentNode.id = headerId;
        sortTable(bodyName, headerId)
    }

    function addConditionalArrows(tableName, colName, threshold) {
        const rows = document.getElementById(tableName).getElementsByTagName('tr');
        let colInd = 0;
        rows[0].id = 'thHidden';
        for (let j = 0, col; col = rows[0].cells[j]; j++) {
            if (rows[0].cells[j].innerHTML === colName) {
              colInd = j;
            }
            rows[0].cells[j].id = 'thHidden'
        }
        let icon;
        for (let i = 1, row; row = rows[i]; i++) {
            row.id = tableName + 'trHidden' + i;
            let val = rows[i].cells[colInd].innerHTML;
            val = parseFloat(val)
            if (Math.abs(val) > parseFloat(threshold)) {
                if (val > 0) {
                    icon = `<i>  </i><i class="fa-solid fa-arrow-up" style="color: #00C851"></i>`;
                }
                if (val < 0) {
                    icon = `<i>  </i><i class="fa-solid fa-arrow-down" style="color: #ff4444"></i>`;
                }
                let iconCell = rows[i].cells[colInd]
                iconCell.innerHTML += icon
            }
        }
    }

    function generateDailyPacing(elem, data, xCol, yCol) {
        const table = document.getElementById('Pacing Table');
        const body = table.getElementsByTagName('tbody');
        const rows = table.querySelectorAll('[id*="tr"]');
        const tableHeadElems = Array.from(table.getElementsByTagName('th'));
        body[0].id = 'accordianPacing';
        for (let i = 0, row; row = rows[i]; i++) {
            for (let j = 0, datum; datum = data[j]; j++) {
                let dailyBreakout = datum['data']['name'];
                let rowBreakouts = [];
                for (let k = 0; k < xCol.length; k++) {
                    rowBreakouts.push(row.cells[k].innerHTML);
                }
                let rowBreakout = rowBreakouts.join("_");
                rowBreakout = rowBreakout.replace(/[^a-zA-Z0-9 ]/g, '');
                rowBreakout = rowBreakout.replace(/\s/g, '');
                if (rowBreakout === dailyBreakout) {
                    hiddenElemHTML = `
                        <tr id="trHidden` + i + `">
                            <td class="hiddenRow" colspan="` + tableHeadElems.length + `">
                            <div  id="collapseRow` + i + `" class="collapse"
                                 aria-labelledby="heading` + i + `"
                                 data-parent="#accordianPacing">
                                <div class="card-body" style="height:300px !important; overflow-y: scroll !important">
                                    <div class="accordion" id="accordianRow` + i + `">`
                        + data[j]['data']['data'] +
                        `</div>
                                </div>
                            </div>
                            </td>
                        </tr>`;
                    row.insertAdjacentHTML('afterend', hiddenElemHTML);
                    addConditionalArrows('accordianRow' + i, 'Day Pacing', 20);
                    for (let k = 0; k < xCol.length; k++) {
                        hideColumn(rowBreakout, xCol[k]);
                    }
                    break;
                }
            }
        }
        addSort('Pacing Table', 'accordianPacing');
    }

    function generateAlertCount(elem, data, xCol, yCol) {
        const elemID = elem.replace('#', '');
        elem = document.getElementById(elemID);
        elem.innerHTML = data[0]['count'];
    }

    function generateAlerts(elem, data, xCol, yCol) {
        const alertElem = document.getElementById("pacingAlerts");
        let alertHtml;
        for (let i = 0, datum; datum = data[i]; i++) {
            alertHtml = `<div class="alert alert-danger" role="alert" style="white-space: pre-line">`
                + datum['msg'] + `</div>`;
            alertElem.innerHTML += alertHtml;
        }
    }

    function radialProgress(selector) {
        const parent = d3.select(selector)
        const size = parent.node().getBoundingClientRect()
        const svg = parent.append('svg')
            .attr('width', size.width)
            .attr('height', size.height);
        const outerRadius = Math.min(size.width, size.height) * 0.45;
        const thickness = 10;
        let value = 0;

        const mainArc = d3.arc()
            .startAngle(0)
            .endAngle(Math.PI * 2)
            .innerRadius(outerRadius - thickness)
            .outerRadius(outerRadius)

        svg.append("path")
            .attr('class', 'radial-progress-bar-bg')
            .attr('transform', `translate(${size.width / 2},${size.height / 2})`)
            .attr('d', mainArc())

        const mainArcPath = svg.append("path")
            .attr('class', 'radial-progress-bar')
            .attr('transform', `translate(${size.width / 2},${size.height / 2})`)

        svg.append("circle")
            .attr('class', 'radial-progress-bar')
            .attr('transform', `translate(${size.width / 2},${size.height / 2 - outerRadius + thickness / 2})`)
            .attr('width', thickness)
            .attr('height', thickness)
            .attr('r', thickness / 2)

        const end = svg.append("circle")
            .attr('class', 'radial-progress-bar')
            .attr('transform', `translate(${size.width / 2},${size.height / 2 - outerRadius + thickness / 2})`)
            .attr('width', thickness)
            .attr('height', thickness)
            .attr('r', thickness / 2)

        let percentLabel = svg.append("text")
            .attr('class', 'progress-label')
            .attr('transform', `translate(${size.width / 2},${size.height / 2})`)
            .text('0%')

        return {
            update: function (progressPercent) {
                const startValue = value
                const startAngle = Math.PI * startValue / 50
                const angleDiff = Math.PI * progressPercent / 50 - startAngle;
                const startAngleDeg = startAngle / Math.PI * 180
                const angleDiffDeg = angleDiff / Math.PI * 180
                const transitionDuration = 1500

                mainArcPath.transition().duration(transitionDuration).attrTween('d', function () {
                    return function (t) {
                        mainArc.endAngle(startAngle + angleDiff * t)
                        return mainArc();
                    }
                })
                end.transition().duration(transitionDuration).attrTween('transform', function () {
                    return function (t) {
                        return `translate(${size.width / 2},${size.height / 2})` +
                            `rotate(${(startAngleDeg + angleDiffDeg * t)})` +
                            `translate(0,-${outerRadius - thickness / 2})`
                    }
                })
                percentLabel.transition().duration(transitionDuration).tween('bla', function () {
                    return function (t) {
                        percentLabel.text(Math.round(startValue + (progressPercent - startValue) * t));
                    }
                })
                value = progressPercent
            }
        }
    }


    function addSelectOptions(data, xCol, selectDiv=false, baseElemId='',
                              defaultValInd=0) {
        let i = 0;
        let newData = $.map(data, function (obj) {
            obj['text'] = obj['text'] || obj[xCol];
            obj['id'] = obj['text'] || obj[xCol];
            obj['value'] = obj['text'] || obj[xCol];
            i++;
            return obj;
        });
        let elemIdJquery = selectDiv ? selectDiv : "#" + xCol + "Select";
        let elemId = elemIdJquery.replace('#', '');
        let elem = document.getElementById(elemId);
        if (!(elem)) {
            let elemToAdd = `
                <select id="${elemId}" class="form-control form-control-sm">
                    <option>Select Metric</option>
                </select>`
            let baseElem = document.getElementById(baseElemId);
            baseElem.insertAdjacentHTML('beforeend', elemToAdd);
            addSelectize();
        }
        let selectizeElem = $(elemIdJquery)[0].selectize;
        selectizeElem.load(function(callback) {
            callback(newData);
        });
        if (Number.isInteger(defaultValInd)) {
            selectizeElem.setValue(data[defaultValInd]['text'])
        }
    }

    $(document).ready(function () {
        $('#chart_type').on('change', function (e) {
            let selectedText = this.options[e.target.selectedIndex].text;
            let dimensionsJquery = '#dimensions';
            if ((selectedText === 'Area') || (selectedText === 'Line')) {
                $(dimensionsJquery).val('eventdate').trigger('change');
                $(dimensionsJquery).prop("disabled", true);
            } else {
                $(dimensionsJquery).prop("disabled", false);
            }
        });
        $('select[id$="filter_col"]').on('change', function (e) {
            let selectedText = this.options[e.target.selectedIndex].text;
            let filterNum = this.id.replace(
                'static_filters-', '').replace('-filter_col', '')
            let elemId = '#static_filters-' + filterNum + '-filter_val'
            $(elemId).empty();
            $(elemId).parent().hide()
            $(elemId).parent().parent().append(
                '<div><div id="loadingBtn"></div></div>')
            let loadingBtnElem = document.getElementById('loadingBtn');
            loadingBtn(loadingBtnElem, '');
            $.ajax({
                type: "POST",
                url: "/get_metrics",
                data: {
                    object_name: "{{ object_name }}",
                    object_type: "{{ title }}",
                    object_level: "{{ edit_name }}",
                    elem: elemId,
                    x_col: selectedText,
                    y_col: ['impressions'].join('|'),
                },
            }).done(function (data, status) {
                $(elemId).parent().show()
                $('#loadingBtn').remove()
                addSelectOptions(data, selectedText, elemId)
            }).fail(function (jqXHR, textStatus) {
                console.log("Request failed: " + textStatus);
            }).always(function () {

            });
        });
    });
</script>