<style id="customSvgStyles">
    .widget {
        height: 25vh;
        width: 175px;
        margin-left: auto;
        margin-right: auto;
    }

    .overlay {
        fill: none;
        pointer-events: all;
    }

    .radial-progress-bar {
        fill: #ddd;
        margin-left: auto;
        margin-right: auto;
        margin-top: auto;
    }

    .radial-progress-bar-bg {
        fill: #3f3f3f;
    }

    .progress-label {
        fill: #aaa;
        font-family: 'Open Sans', sans-serif;
        font-size: 15px;
        text-anchor: middle;
        dominant-baseline: central;
    }

    .outer {
        overflow: auto;
    }

    .bubble circle {
        stroke-width: 2px;
        stroke: white;
        opacity: 0.4;
    }

    .bubble:hover circle {
        stroke: black;
        opacity: 1;
    }

    .bubble-label {
        alignment-baseline: central;
        paint-order: stroke;
        stroke: white;
        stroke-width: 3px;
        font-weight: 600;
    }
</style>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
    function autoMargin(elem, maxHeight, lMargin, bMargin, dataLength = 1,
                        dataLengthY = 1, equalSides = false, tMargin = 15) {
        const parent = d3.select(elem);
        const size = parent.node().getBoundingClientRect()
        if (equalSides) {
            maxHeight = size.width;
        }
        let margin = {top: tMargin, right: lMargin, bottom: bMargin, left: lMargin},
            width = (size.width - margin.left - margin.right) * dataLength,
            height = (maxHeight - margin.top - margin.bottom) * dataLengthY;
        let svgHeight = height + margin.top + margin.bottom
        let svg = parent
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", svgHeight)
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");
        return {margin: margin, width: width, height: height, svg: svg}
    }

    function generateSelect(elem, allGroup, selectElem = 'Select',
                            defaultVal=0) {
        let buttonSelector = elem + selectElem;
        let elemToAdd = `
            <select id="${buttonSelector}" class="form-control form-control-sm">
            </select>`;
        $(buttonSelector).html(elemToAdd);
        d3.select(buttonSelector)
            .selectAll('myOptions')
            .data(allGroup)
            .enter()
            .append('option')
            .text(function (d) {
                return d;
            }) // text showed in the menu
            .attr("value", function (d) {
                return d;
            }) // corresponding value returned by the button
        allGroup = allGroup.map(x => {
            return ({text: x});
        });
        addSelectOptions(allGroup, '', buttonSelector, elem.replace('#', ''),
            defaultVal);
    }

    function wrapText(text, width, x=0) {
        text.each(function () {
            var text = d3.select(this),
                words = text.text().split(/[ _]+/).reverse(),
                word,
                line = [],
                lineNumber = (x) ? 1 : 0,
                lineHeight = 1.1, // ems
                y = text.attr("y"),
                dy = parseFloat(text.attr("dy")),
                tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");
            let curLen = 0
            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(" "));
                curLen += word.length;
                if (curLen > 13) {
                    let joinedLine = line.join(" ");
                    if (joinedLine.length > 11) {
                        joinedLine = joinedLine.substring(0, 8) + '...';
                    }
                    tspan.text(joinedLine);
                    break;
                }
                if (tspan.node().getComputedTextLength() > width) {
                    line.pop();
                    tspan.text(line.join(" "));
                    line = [word];
                    tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", lineNumber * lineHeight + dy + "em").text(word);
                    ++lineNumber
                }
            }
        });
    }

    function getUnits(col, precision=',.2s') {
        let costPer = 'CP';
        let units = {
            [costPer]: '$',
            'Net Cost Final': '$',
            'CTR': '%',
            'VTR': '%',
            'VCR': '%',
            'eventdate': null,
            'Date': null
        };
        if (col.startsWith(costPer)) {
            return units[costPer] + precision
        }
        if (col in units) {
            if (units[col]) {
                return units[col] + precision
            }
            else {
                return units[col]
            }
        }
        return precision
    }

    function generateY1Axis(data, svg, xAxisType, yAxisType, width, height,
                            xCol, yCol, timeX = null, y1AxisType = null, y1Col = null,
                            ticks=null) {
        let y1Unit = getUnits(y1Col);
        let y1Scale = y1AxisType
            .domain([0, d3.max(data, function (d) {
                return +d[y1Col];
            })])
            .range([height, 0]);
        let y1Axis = d3.axisRight(y1Scale);
        svg.append("g")
            .attr('class', 'y1axis')
            .attr("transform", "translate(" + width + " ,0)")
            .call(y1Axis)
            .call(y1Axis.ticks(ticks, y1Unit))
        return {y1Scale: y1Scale, y1Axis: y1Axis}
    }

    function generateX1Axis(data, svg, xAxisType, yAxisType, width, height,
                            xCol, yCol, timeX = null, x1AxisType = null, x1Col = null,
                            ticks=null) {
        let x1Unit = getUnits(x1Col);
        let x1Scale = x1AxisType
            .domain([0, d3.max(data, function (d) {
                return +d[x1Col];
            })])
            .range([0, width])
        let x1Axis = d3.axisTop(x1Scale);
        svg.append("g")
            .attr('class', 'x1axis')
            .call(x1Axis)
            .call(x1Axis.ticks(ticks, x1Unit));
        return {x1Scale: x1Scale, x1Axis: x1Axis}
    }

    function flipAxis(xAxisType, yAxisType, xCol, yCol, xDomain, yDomain) {
        [xAxisType, yAxisType] = [yAxisType, xAxisType];
        [xCol, yCol] = [yCol, xCol];
        [xDomain, yDomain] = [yDomain, xDomain];
        return [xAxisType, yAxisType, xCol, yCol, xDomain, yDomain];
    }

    function generateAxis(data, svg, xAxisType, yAxisType, width, height,
                          xCol, yCol, timeX = null, y1AxisType=null, y1Col=null,
                          domainX = null, domainY = null, centerAxis = false,
                          x1AxisType = null, x1Col = null, ticks=null) {
        let xDomain = function (xCol) {
            if (domainX) {
                return domainX;
            } else if (timeX) {
                return d3.extent(data, function (d) {
                    return d[xCol];
                })
            } else {
                return data.map(function (d) {
                    return d[xCol];
                })
            }
        };
        let yDomain = function (yCol) {
            if (domainY) {
                return domainY;
            } else {
                return [0, d3.max(data, function (d) {
                    return +d[yCol];
                })]
            }
        };
        if (x1Col) {
            [xAxisType, yAxisType, xCol, yCol, xDomain, yDomain] =
                flipAxis(xAxisType, yAxisType, xCol, yCol, xDomain, yDomain);
        }
        let xUnit = getUnits(xCol);
        let yUnit = getUnits(yCol);

        let x = xAxisType
            .domain(xDomain(xCol))
            .range([0, width])
        if (!timeX && x.name === 'i') {
            x.padding(1)
        }
        let xAxis = d3.axisBottom(x)
        let transHeight = height;
        let transWidth = 0;
        if (centerAxis) {
            transHeight = 0.5*height;
            transWidth = 0.5*width;
        }
        svg.append("g")
            .attr("transform", "translate(0," + transHeight + ")")
            .attr('class', 'xaxis')
            .call(xAxis)
            .call(xAxis.ticks(ticks, xUnit));
        if (!timeX && x.name === 'i') {
            svg.selectAll('.xaxis')
                .selectAll(".tick text")
                .call(wrapText, x.bandwidth());
        }
        let yScale = yAxisType
            .domain(yDomain(yCol))
            .range([height, 0]);
        let yAxis = d3.axisLeft(yScale);
        svg.append("g")
            .attr("transform", "translate(" + transWidth + ", 0)")
            .attr('class', 'yaxis')
            .call(yAxis)
            .call(yAxis.ticks(ticks, yUnit));
        if (x1Col && yAxis.name === 'h') {
            svg.selectAll('.yaxis')
                .selectAll(".tick text")
                .call(wrapText, yScale.bandwidth(), -9);
        }
        let y1Props = {};
        if (y1Col) {
            y1Props = generateY1Axis(data, svg, xAxisType, yAxisType, width, height,
                xCol, yCol, timeX, y1AxisType, y1Col, ticks)
        }
        let x1Props;
        if (x1Col) {
            x1Props = generateX1Axis(data, svg, xAxisType, yAxisType, width, height,
                xCol, yCol, timeX, x1AxisType, x1Col, ticks)
        }
        return {...{x: x, yScale: yScale, yAxis: yAxis, xAxis: xAxis},
            ...y1Props, ...x1Props}
    }

    function getColorPal(allGroup) {
        let myColor = d3.scaleOrdinal()
            .domain(allGroup)
            .range(d3.schemeTableau10);
        return myColor
    }

    function sortData(data, col) {
        return data.sort((a, b) => b[col] - a[col])
    }

    function updateYAxis(axes, data, svg, selectedVar, scale = null, axis = null,
                         axisSelector = ".yaxis", ticks=null) {
        axis = (axis) ? axis : axes.yAxis;
        scale = (scale) ? scale : axes.yScale;
        let yUnits = getUnits(selectedVar)
        scale.domain([0, d3.max(data, function (d) {
            return +d[selectedVar]
        })]);
        svg.selectAll(axisSelector)
            .transition().duration(500)
            .call(axis)
            .call(axis.ticks(ticks, yUnits))
    }

    function addToolTip(svg, am, axes, data, xCol, selectedVar, myColor, timeX,
                        scale = null, selectedVar1 = null, scale1 = null, scaleX = null) {
        scale = (scale) ? scale : axes.yScale;
        scale1 = (scale1) ? scale1 : axes.yScale;
        let flip = (scaleX !== null);
        scaleX = (scaleX) ? scaleX : axes.x;
        let dateFormatter = d3.timeFormat("%m/%d/%y");
        let formatValue = d3.format(getUnits(selectedVar, ',.4f'));
        let focus = svg.append("g")
            .attr("class", "focus");
        let focus1 = svg.append("g")
            .attr("class", "focus1");

        focus.append("circle")
            .attr("r", 5)
            .attr("fill", function (d) {
                return myColor(selectedVar)
            });

        focus.append("div")
            .style("opacity", 0)
            .attr("class", "tooltip")
            .style("background-color", "white")
            .style("border", "solid")
            .style("border-width", "2px")
            .style("border-radius", "5px")
            .style("padding", "5px");

        let yPos = 18;
        focus.append("text")
            .attr("class", "tooltip-y")
            .attr("x", 18)
            .attr("y", -2);
        if (selectedVar1) {
            focus1.append("circle")
                .attr("r", 5)
                .attr("fill", function (d) {
                    return myColor(selectedVar1)
                });
            focus.append("text")
                .attr("class", "tooltip-y1")
                .attr("x", 18)
                .attr("y", yPos);
            yPos += 20;
        }
        focus.append("text")
            .attr("class", "tooltip-x")
            .attr("x", 18)
            .attr("y", yPos);


        svg.append("rect")
            .attr("class", "overlay")
            .attr("width", am.width)
            .attr("height", am.height)
            .on("mouseover", function () {
                focus.attr("display", null);
                focus.attr("fill-opacity", .7)
                if (selectedVar1) {
                    focus1.attr("display", null);
                    focus1.attr("fill-opacity", .7);
                }
            })
            .on("mouseout", function () {
                focus.attr("display", "none");
                focus.attr("fill-opacity", .3);
                if (selectedVar1) {
                    focus1.attr("display", "none");
                    focus1.attr("fill-opacity", .3);
                }
            })
            .on("mousemove", mousemove);
        let bisectDate = d3.bisector(function (d) {
            return d[xCol];
        }).left

        function mousemove(event) {
            let dGet = function (currentThis) {
                let coord = (flip) ? 1 : 0;
                if (timeX) {
                    let x0 = scaleX.invert(d3.pointer(event, currentThis)[coord]);
                    let i = bisectDate(data, x0, 1);
                    let d0 = data[i - 1];
                    let d1 = data[i];
                    return x0 - d0[xCol] > d1[xCol] - x0 ? d1 : d0
                } else {
                    let mx = d3.pointer(event, currentThis)[coord]; // ? x : y position of cursor
                    let idx = Math.round((mx / scaleX.step()) - scaleX.padding());
                    idx = (flip) ? (data.length - 1 - idx) : idx;
                    return data[idx]
                }
            }
            let d = dGet(this)
            let xColVal = (timeX) ? dateFormatter(d[xCol]) : d[xCol];
            let y, y1, x, x1;
            if (flip) {
                y = scaleX(d[xCol]) + am.margin.top - (15/2);
                x = scale(d[selectedVar]);
                focus.attr("transform", "translate(" + x + "," + y + ")");
            } else {
                focus.attr("transform", "translate(" + scaleX(d[xCol]) + "," + scale(d[selectedVar]) + ")");
            }
            focus.select(".tooltip-y").text(selectedVar + ": " + formatValue(d[selectedVar]));
            if (selectedVar1) {
                let formatValue1 = d3.format(getUnits(selectedVar1, '.4f'));
                if (flip) {
                    y1 = scaleX(d[xCol]) + am.margin.top - (25/2);
                    x1 = scale1(d[selectedVar1]);
                    focus1.attr("transform", "translate(" + x1 + "," + y1 + ")");
                } else {
                    focus1.attr("transform", "translate(" + scaleX(d[xCol]) + "," + scale1(d[selectedVar1]) + ")");
                }
                focus.select(".tooltip-y1").text(selectedVar1 + ": " + formatValue1(d[selectedVar1]));
            }
            focus.select(".tooltip-x").text(xCol + ": " + xColVal);
            focus.style("left", (d3.pointer(event, this)[0] + 70) + "px");
            focus.style("top", (d3.pointer(event, this)[1]) + "px");
            let position = (flip) ? x : d3.pointer(event, svg.node())[0];
            focus.style("margin", "5px");
            if (position > (svg.node().parentNode.width.baseVal.value / 2)) {
                focus.style("text-anchor", "end");
                focus.selectAll("text").each(function (d, i) {
                    d3.select(this).attr('x', '-18');
                });
            } else {
                focus.style("text-anchor", "start");
                focus.selectAll("text").each(function (d, i) {
                    d3.select(this).attr('x', '18');
                });
            }
        }
    }

    function getAreaGenerator(axes, xCol, selectedVar) {
        return d3.area()
            .x(function (d) {
                return axes.x(d[xCol])
            })
            .y0(axes.yScale(0))
            .y1(function (d) {
                return axes.yScale(d[selectedVar])
            })
            .curve(d3.curveMonotoneX)
    }

    function getLineGenerator(axes, xCol, selectedVar, scale) {
        return d3.line()
            .x(function (d) {
                return axes.x(d[xCol])
            })
            .y(function (d) {
                return scale(d[selectedVar])
            })
            .curve(d3.curveMonotoneX)
    }

    function addClipBrush(svg, am, idleTimeout, idled, axes, u, xCol, selectedVar) {
        // Add brushing
        var clip = svg.append("defs").append("svg:clipPath")
            .attr("id", "clip")
            .append("svg:rect")
            .attr("width", am.width)
            .attr("height", am.height)
            .attr("x", 0)
            .attr("y", 0);

        // Add brushing
        var brush = d3.brushX()                   // Add the brush feature using the d3.brush function
            .extent([[0, 0], [am.width, am.height]])  // initialise the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
            .on("end", updateChartFromClipBrush)               // Each time the brush selection changes, trigger the 'updateChart' function

        function updateChartFromClipBrush() {

            // What are the selected boundaries?
            let extent = d3.event.selection
            // If no selection, back to initial coordinate. Otherwise, update X axis domain
            if (!extent) {
                if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // This allows to wait a little bit
                axes.x.domain([4, 8])
            } else {
                axes.x.domain([axes.x.invert(extent[0]), axes.x.invert(extent[1])])
                u.select(".brush").call(brush.move, null) // This remove the grey brush area as soon as the selection has been done
            }
            // Update axis and area position
            svg.selectAll(".xaxis")
                .transition().duration(500)
                .call(axes.xAxis)
            let areaGenerator = getAreaGenerator(axes, xCol, selectedVar)
            u
                .select('.lineTest')
                .transition()
                .duration(1000)
                .attr("d", areaGenerator)
        }

        return {clip: clip, brush: brush}
    }

    function groupData() {
        var nested_data = d3.nest()
            .key(function (d) {
                return d.Clicked;
            })
            .key(function (d) {
                return d.Campaign
            })
            .rollup(function (values) {
                return values.length;
            })
            .entries(data);
    }

    function generateHistogram() {
        // set the dimensions and margins of the graph
        var margin = {top: 10, right: 30, bottom: 30, left: 40},
            width = 460 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg = d3.select("#my_dataviz")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");

        // get the data
        d3.json("/get_metrics").then(function (data) {

            // X axis: scale and draw:
            var x = d3.scaleLinear()
                .domain([0, 1000])     // can use this instead of 1000 to have the max of data: d3.max(data, function(d) { return +d.price })
                .range([0, width]);
            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // set the parameters for the histogram
            var histogram = d3.histogram()
                .value(function (d) {
                    return d.price;
                })   // I need to give the vector of value
                .domain(x.domain())  // then the domain of the graphic
                .thresholds(x.ticks(70)); // then the numbers of bins

            // And apply this function to data to get the bins
            var bins = histogram(data);

            // Y axis: scale and draw:
            var y = d3.scaleLinear()
                .range([height, 0]);
            y.domain([0, d3.max(bins, function (d) {
                return d.length;
            })]);   // d3.hist has to be called before the Y axis obviously
            svg.append("g")
                .call(d3.axisLeft(y));

            // append the bar rectangles to the svg element
            svg.selectAll("rect")
                .data(bins)
                .enter()
                .append("rect")
                .attr("x", 1)
                .attr("transform", function (d) {
                    return "translate(" + x(d.x0) + "," + y(d.length) + ")";
                })
                .attr("width", function (d) {
                    return x(d.x1) - x(d.x0) - 1;
                })
                .attr("height", function (d) {
                    return height - y(d.length);
                })
                .style("fill", "#69b3a2")

        });
    }

    function generateLineChart(elem, data, xCol, yCol) {
        let am = autoMargin(elem, 500, 60, 30);
        let svg = am.svg
        let parseDate = d3.timeParse("%Y-%m-%d");
        data.forEach(function (d) {
            d[xCol] = parseDate(d[xCol]);
        });
        data.sort((a, b) => a[xCol] - b[xCol]);
        generateSelect(elem, yCol)
        // A color scale: one color for each group
        let myColor = getColorPal(yCol)
        let axes = generateAxis(
            data, svg, d3.scaleTime(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], true
        )

        // A function that update the chart
        function update(selectedVar) {
            updateYAxis(axes, data, svg, selectedVar)
            let lineGenerator = getLineGenerator(axes, xCol, selectedVar,
                axes.yScale)
            let u = svg.selectAll(".lineTest")
                .data([data])
            u
                .enter()
                .append("path")
                .attr("class", "lineTest")
                .merge(u)
                .transition()
                .duration(1000)
                .attr("d", lineGenerator)
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 4)
                .attr("fill", "none")
            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor, true)
        }
        // When the button is changed, run the updateChart function
        d3.select(elem + 'Select').on("change", function (d) {
            // recover the option that has been chosen
            let selectedOption = d3.select(this).property("value")
            // run the updateChart function with this selected option
            update(selectedOption)
        })
        update(yCol[0])
    }

    function generateAreaChart(elem, data, xCol, yCol, filterCols) {
        elem = (elem[0] === '#') ? elem : `#${elem}`;
        let am = autoMargin(elem, 250, 60, 30);
        let svg = am.svg
        let parseDate = d3.timeParse("%Y-%m-%d");
        data.forEach(function (d) {
            d[xCol] = parseDate(d[xCol]);
        });
        generateSelect(elem, yCol)
        // generateSelect(elem, filterCols, 'SelectDimension')
        // A color scale: one color for each group
        let myColor = getColorPal(yCol)
        let axes = generateAxis(
            data, svg, d3.scaleTime(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], true
        )

        // A function that update the chart
        function update(selectedVar, selectedDim = null) {
            updateYAxis(axes, data, svg, selectedVar)
            let areaGenerator = getAreaGenerator(axes, xCol, selectedVar)
            let u = svg.selectAll(".lineTest")
                .data([data])
                .attr("clip-path", "url(#clip)")
            u
                .enter()
                .append("path")
                .attr("class", "lineTest")
                .merge(u)
                .transition()
                .duration(1000)
                .attr("d", areaGenerator)
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 1)
                .attr("fill-opacity", .3)
                .attr("fill", function (d) {
                    return myColor(selectedVar)
                })
            var idleTimeout = null

            function idled() {
                idleTimeout = null;
            }

            let clipBrush = addClipBrush(svg, am, idleTimeout,
                idled, axes, u, xCol, selectedVar)
            u
                .enter()
                .append("g")
                .attr("class", "brush")
                .call(clipBrush.brush);
            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor, true)
        }

        $(elem + 'Select').on("change", function (e) {
            let selectedOption = $(e.currentTarget).val();
            update(selectedOption)
        })

        // If user double click, reinitialize the chart
        svg.on("dblclick", function () {
            axes.x.domain(d3.extent(data, function (d) {
                return d[xCol];
            }))
            svg.selectAll(".xaxis")
                .transition().duration(500)
                .call(axes.xAxis)
            update(yCol[0])
        });
        update(yCol[0])
    }


    function generateDualLineChart(elem, data, xCol, yCol, filterCols) {
        elem = (elem[0] === '#') ? elem : `#${elem}`;
        let elemId = elem.replace('#', '');
        document.getElementById(elemId).innerHTML = '';
        let am = autoMargin(elem, 400, 60, 30);
        let svg = am.svg;
        let parseDate = d3.timeParse("%Y-%m-%d");
        data.forEach(function (d) {
            d[xCol] = parseDate(d[xCol]);
        });
        data.sort((a, b) => a[xCol] - b[xCol]);
        generateSelect(elem, yCol, "Select0");
        generateSelect(elem, yCol, "Select1", 1);
        // generateSelect(elem, filterCols, 'SelectDimension')
        // A color scale: one color for each group
        let myColor = getColorPal(yCol);
        let axes = generateAxis(
            data, svg, d3.scaleTime(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], true, d3.scaleLinear(), yCol[1]
        );

        // A function that update the chart
        function update(selectedVar, selectedDim = null, yAxis, line, selectedVar1) {
            let scale = (yAxis === '.yaxis') ? axes.yScale :  axes.y1Scale;
            let scale1 = (yAxis === '.yaxis') ? axes.y1Scale :  axes.yScale;
            let axis = (yAxis === '.yaxis') ? axes.yAxis : axes.y1Axis;
            let fill = (yAxis === '.yaxis') ? .3 : 0;
            updateYAxis(axes, data, svg, selectedVar, scale, axis, yAxis);
            let lineGenerator = (yAxis === '.yaxis') ?
                getAreaGenerator(axes, xCol, selectedVar, scale) :
                getLineGenerator(axes, xCol, selectedVar, scale);
            let u = svg.selectAll(''.concat(".", line))
                .data([data])
                .attr("clip-path", "url(#clip)");
            u
                .enter()
                .append("path")
                .attr("class", line)
                .merge(u)
                .transition()
                .duration(1000)
                .attr("d", lineGenerator)
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 3)
                .attr("fill-opacity", fill)
                .attr("fill", function (d) {
                    return myColor(selectedVar)
                })
            d3.selection.prototype.last = function() {
              var last = this.size() - 1;
              return d3.select(this['_groups'][0][last]);
            };
            svg.call(g => g.selectAll(yAxis).selectAll('.tick > text')
                  .attr('fill', "currentColor"));
            svg.call(g => g.selectAll(yAxis).selectAll('.tick > text').last()
                  .attr('fill', myColor(selectedVar)));
            var idleTimeout = null

            function idled() {
                idleTimeout = null;
            }

            let clipBrush = addClipBrush(svg, am, idleTimeout,
                idled, axes, u, xCol, selectedVar);
            u
                .enter()
                .append("g")
                .attr("class", "brush")
                .call(clipBrush.brush);
            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor, true,
                scale, selectedVar1, scale1)
        }

        $(elem + 'Select0').on("change", function (e) {
            let selectedOption = $(e.currentTarget).val();
            let selectedOption1 = $(elem + 'Select1').val();
            let color = myColor(selectedOption);
            let colorOpacity = hexToRgb(color);
            colorOpacity = colorOpacity.replace('1)', '.3)');
            let style = ('border-color: ' + color + ' !important;' +
                'background-color: ' + colorOpacity);
            update(selectedOption, null, ".yaxis", "line0", selectedOption1);
            update(selectedOption1, null, ".y1axis", "line1", selectedOption);
            $(elem + 'Select0Key').attr('style', style);
        });
        $(elem + "Select1").on("change", function (e) {
            let selectedOption1 = $(e.currentTarget).val();
            let selectedOption = $(elem + 'Select0').val();
            update(selectedOption, null, ".yaxis", "line0", selectedOption1);
            update(selectedOption1, null, ".y1axis", "line1", selectedOption);
            $(elem + 'Select1Key').css('background-color',
                myColor(selectedOption1))
        });

        // If user double click, reinitialize the chart
        svg.on("dblclick", function () {
            axes.x.domain(d3.extent(data, function (d) {
                return d[xCol];
            }))
            svg.selectAll(".xaxis")
                .transition().duration(500)
                .call(axes.xAxis);
            update(yCol[0], null, ".yaxis", "line0", yCol[1]);
            update(yCol[1], null, ".y1axis", "line1", yCol[0])
        });
        update(yCol[0], null, ".yaxis", "line0", yCol[1]);
        update(yCol[1], null, ".y1axis", "line1", yCol[0]);
        let color = myColor(yCol[0]);
        let colorOpacity = hexToRgb(color);
        colorOpacity = colorOpacity.replace('1)', '.3)');
        let style = ('border-color: ' + color + ' !important;' +
            'background-color: ' + colorOpacity);
        $(elem + 'Select0Key').attr('style', style);
        $(elem + 'Select1Key').css('background-color',
            myColor(yCol[1]));
    }

    function generateLollipopChart(elem, data, xCol, yCol) {
        elem = (elem[0] === '#') ? elem : `#${elem}`;
        data = sortData(data, yCol[0])
        let dataLength = (data.length < 20) ? 1 : data.length / 20
        let am = autoMargin(elem, 250, 60, 30, dataLength);
        let svg = am.svg
        generateSelect(elem, yCol)
        let myColor = getColorPal(yCol)
        let axes = generateAxis(
            data, svg, d3.scaleBand(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], false
        )

        function update(selectedVar) {
            updateYAxis(axes, data, svg, selectedVar);
            // variable u: map data to existing circle
            var j = svg.selectAll(".myLine")
                .data(data)
            // update lines
            j
                .enter()
                .append("line")
                .attr("class", "myLine")
                .merge(j)
                .transition()
                .duration(1000)
                .attr("x1", function (d) {
                    return axes.x(d[xCol]);
                })
                .attr("x2", function (d) {
                    return axes.x(d[xCol]);
                })
                .attr("y1", axes.yScale(0))
                .attr("y2", function (d) {
                    return axes.yScale(d[selectedVar]);
                })
                .attr("stroke", "grey")


            // variable u: map data to existing circle
            var u = svg.selectAll("circle")
                .data(data)
            // update bars
            u
                .enter()
                .append("circle")
                .merge(u)
                .transition()
                .duration(1000)
                .attr("cx", function (d) {
                    return axes.x(d[xCol]);
                })
                .attr("cy", function (d) {
                    return axes.yScale(d[selectedVar]);
                })
                .attr("r", 8)
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 1)
                .attr("fill", function (d) {
                    return myColor(selectedVar)
                })
                .attr("fill-opacity", .3)

            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor)
        }

        $(elem + 'Select').on("change", function (e) {
            let selectedOption = $(e.currentTarget).val();
            update(selectedOption)
        })

        update(yCol[0])
    }

    function generateMiniChart(elem, axes, am) {

        var svg = d3.select("svg"),
            margin2 = {top: 430, right: 20, bottom: 30, left: 40},
            width = +svg.attr("width") - axes.margin.left - axes.margin.right,
            height2 = +svg.attr("height") - margin2.top - margin2.bottom;
        var x2 = d3.scaleTime().range([0, width]),
            y2 = d3.scaleLinear().range([height2, 0]);

        var xAxis2 = d3.axisBottom(x2)

        var brush = d3.brushX()
            .extent([[0, 0], [width, height2]])
            .on("brush end", brushed);

        var zoom = d3.zoom()
            .scaleExtent([1, Infinity])
            .translateExtent([[0, 0], [width, am.height]])
            .extent([[0, 0], [width, am.height]])
            .on("zoom", zoomed);

        var area2 = d3.area()
            .curve(d3.curveMonotoneX)
            .x(function (d) {
                return x2(d[xCol]);
            })
            .y0(height2)
            .y1(function (d) {
                return y2(d[selectedVar]);
            });

        svg.append("defs").append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("width", width)
            .attr("height", height);

        var focus = svg.append("g")
            .attr("class", "focus")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var context = svg.append("g")
            .attr("class", "context")
            .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

        function brushed() {
            if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
            var s = d3.event.selection || x2.range();
            x.domain(s.map(x2.invert, x2));
            focus.select(".area").attr("d", area);
            focus.select(".axis--x").call(xAxis);
            svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
                .scale(width / (s[1] - s[0]))
                .translate(-s[0], 0));
        }

        function zoomed() {
            if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
            var t = d3.event.transform;
            x.domain(t.rescaleX(x2).domain());
            focus.select(".area").attr("d", area);
            focus.select(".axis--x").call(xAxis);
            context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
        }

        function type(d) {
            d.date = parseDate(d.date);
            d.price = +d.price;
            return d;
        }
    }

    function generateBubbleChart(elem, data, xCol, yCol, labelCol,
                                 domainX = null, domainY = null,
                                 centerAxis = false) {
        const elemId = elem.replace('#', '');
        document.getElementById(elemId).innerHTML = '';
        let am = autoMargin(elem, 768, 60, 60, 1, 1, true);
        let svg = am.svg;
        let myColor = getColorPal(yCol);
        let axes = generateAxis(
            data, svg, d3.scaleLinear(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], false, null, null, domainX, domainY, centerAxis
        );
        svg.append("g")
            .append("text")
            .attr("transform",
                "translate(" + [am.width*0.5 + 10, 10] + ")")
            .text(yCol);
        svg.append("g")
            .append("text")
            .attr("transform",
                "translate(" + [am.width - 60, am.height*0.5 - 10] + ")")
            .text(xCol);
        let tooltip = d3.select(elem)
            .append("div")
              .style("opacity", 0)
              .attr("class", "tooltip")
              .style("background-color", "white")
              .style("border", "solid")
              .style("border-width", "2px")
              .style("border-radius", "5px")
              .style("padding", "5px");

        let showTooltip = function(d) {
            tooltip
              .transition()
              .duration(200)
            tooltip
              .style("opacity", 1)
              .style("pointer-events", "none")
              .html(xCol + ": " + d[xCol].toPrecision(2) + "<br>"
                + yCol[0] + ": " + d[yCol[0]].toPrecision(2))
              .style("left", (d3.mouse(this)[0]+50) + "px")
              .style("top", (d3.mouse(this)[1]+100) + "px")
        }

        let moveTooltip = function(d) {
            tooltip
              .style("left", (d3.mouse(this)[0]+50) + "px")
              .style("top", (d3.mouse(this)[1]+100) + "px")
        }

        let hideTooltip = function(d) {
            tooltip
              .transition()
              .duration(200)
              .style("opacity", 0)
        }

        function update(selectedVar) {
            var j = svg.selectAll("circle")
                .data(data)

            let enterElem = j
                .enter()
                .append("g")
                    .attr("class", "bubble")
                    .on("mouseover", showTooltip )
                    .on("mousemove", moveTooltip )
                    .on("mouseleave", hideTooltip );

            enterElem
                .append("circle")
                    .attr("cx", function (d) {
                        return axes.x(d[xCol]);
                    })
                    .attr("cy", function (d) {
                        return axes.yScale(d[selectedVar]);
                    })
                    .attr("r", 24)
                    .attr("fill", function (d) {
                        return myColor(selectedVar);
                    });

            enterElem
                .append("text")
                    .attr("class", "bubble-label")
                    .attr("x", function(d) {
                        return axes.x(d[xCol]);
                    })
                    .attr("y", function(d) {
                        return axes.yScale(d[selectedVar]);
                    })
                    .attr("text-anchor", "middle")
                    .text(function(d) {return d[labelCol];});
        }
        update(yCol[0]);
    }

    function generateDualBarChart(elem, data, xCol, yCol) {
        elem = (elem[0] === '#') ? elem : `#${elem}`;
        let elemId = elem.replace('#', '');
        document.getElementById(elemId).innerHTML = '';
        data = sortData(data, yCol[0]);
        let dataLength = (data.length < 10) ? 1 : data.length / 10;
        let height = Math.max(data.length * 60, 580);
        let am = autoMargin(elem, height, 75, 30, dataLength, 1, false, 30);
        let svg = am.svg;
        generateSelect(elem, yCol, "Select0");
        generateSelect(elem, yCol, "Select1", 1);
        // A color scale: one color for each group
        let myColor = getColorPal(yCol);

        let axes = generateAxis(
            data, svg, d3.scaleBand(), d3.scaleLinear(), 250, am.height,
            xCol, yCol[0], false, null, null, null, null, false,
            d3.scaleLinear(), yCol[1], 5);

        function update(selectedVar, selectedDim = null, xAxis, bar, selectedVar1) {
            let scale = (xAxis === '.xaxis') ? axes.x :  axes.x1Scale;
            let scale1 = (xAxis === '.xaxis') ? axes.x1Scale :  axes.x;
            let axis = (xAxis === '.xaxis') ? axes.xAxis : axes.x1Axis;
            let width = (xAxis === '.xaxis') ? 25  : 15;
            // Add Y axis
            updateYAxis(axes, data, svg, selectedVar, scale, axis, xAxis, 5);
            // variable u: map data to existing circle
            var j = svg.selectAll(''.concat(".", bar))
                .data(data);
            // update lines
            j
                .enter()
                .append("rect")
                .attr("class", bar)
                .merge(j)
                .transition()
                .duration(1000)
                .attr("y", function (d) {
                    return axes.yScale(d[xCol]) + am.margin.top - (width/2);
                })
                .attr("height", width)
                .attr("width", function (d) {
                    return scale(d[selectedVar]);
                })
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 1)
                .attr("fill", function (d) {
                    return myColor(selectedVar)
                })
                .attr("fill-opacity", .3)
            // generateMiniChart(elem)
            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor, false,
                scale, selectedVar1, scale1, axes.yScale)
        }

        function updateColorKey(selectedOption, elem, key) {
            let color = myColor(selectedOption);
            let colorOpacity = hexToRgb(color);
            colorOpacity = colorOpacity.replace('1)', '.3)');
            let style = ('border-color: ' + color + ' !important;' +
                'background-color: ' + colorOpacity);
             $(elem + key).attr('style', style);
        }

        $(elem + 'Select0').on("change", function (e) {
            let selectedOption = $(e.currentTarget).val();
            let selectedOption1 = $(elem + 'Select1').val();
            update(selectedOption, null, ".xaxis", "bar0", selectedOption1);
            update(selectedOption1, null, ".x1axis", "bar1", selectedOption);
            updateColorKey(selectedOption, elem, 'Select0Key')
        });
        $(elem + "Select1").on("change", function (e) {
            let selectedOption1 = $(e.currentTarget).val();
            let selectedOption = $(elem + 'Select0').val();
            update(selectedOption, null, ".xaxis", "bar0", selectedOption1);
            update(selectedOption1, null, ".x1axis", "bar1", selectedOption);
            updateColorKey(selectedOption1, elem, 'Select1Key')
        });

        update(yCol[0], null, ".xaxis", "bar0", yCol[1]);
        update(yCol[1], null, ".x1axis", "bar1", yCol[0]);
        updateColorKey(yCol[0], elem, 'Select0Key')
        updateColorKey(yCol[1], elem, 'Select1Key')
    }

    function generateBarChart(elem, data, xCol, yCol) {
        elem = (elem[0] === '#') ? elem : `#${elem}`;
        let elemId = elem.replace('#', '');
        document.getElementById(elemId).innerHTML = '';
        data = sortData(data, yCol[0]);
        let dataLength = (data.length < 10) ? 1 : data.length / 10;
        let am = autoMargin(elem, 250, 60, 30, dataLength);
        let svg = am.svg;
        generateSelect(elem, yCol);
        // A color scale: one color for each group
        let myColor = getColorPal(yCol);
        let axes = generateAxis(
            data, svg, d3.scaleBand(), d3.scaleLinear(), am.width, am.height,
            xCol, yCol[0], false);

        function update(selectedVar) {
            // Add Y axis
            updateYAxis(axes, data, svg, selectedVar);
            // variable u: map data to existing circle
            var j = svg.selectAll(".bar")
                .data(data)
            // update lines
            j
                .enter()
                .append("rect")
                .attr("class", "bar")
                .merge(j)
                .transition()
                .duration(1000)
                .attr("x", function (d) {
                    return axes.x(d[xCol]);
                })
                .attr("y", function (d) {
                    return axes.yScale(d[selectedVar]);
                })
                .attr("width", 20)
                .attr("height", function (d) {
                    return am.height - axes.yScale(d[selectedVar]);
                })
                .attr("stroke", function (d) {
                    return myColor(selectedVar)
                })
                .attr("stroke-width", 1)
                .attr("fill", function (d) {
                    return myColor(selectedVar)
                })
                .attr("fill-opacity", .3)
            // generateMiniChart(elem)
            addToolTip(svg, am, axes, data, xCol, selectedVar, myColor)
        }

        $(elem + 'Select').on("change", function (e) {
            let selectedOption = $(e.currentTarget).val();
            update(selectedOption)
        })

        update(yCol[0])
    }

    function generateWorldMap(elem, data, xCol, yCol) {
        let am = autoMargin(elem, 500, 0, 0);    // example data from server
    }

    function generateCircularBarplot(elem, data, xCol, yCol) {
        data = sortData(data, yCol[0])
        const parent = d3.select(elem)
        const size = parent.node().getBoundingClientRect()
        const svg = parent.append('svg')
            .attr('width', size.width)
            .attr('height', 500)
            .append("g")
            .attr("transform", "translate(" + (size.width / 2) + "," + (250) + ")");

        let innerRadius = 10;
        let outerRadius = Math.min(size.width, 250) / 2;

        var x = d3.scaleBand()
            .range([0, 2 * Math.PI])    // X axis goes from 0 to 2pi = all around the circle. If I stop at 1Pi, it will be around a half circle
            .align(0)                  // This does nothing
            .domain(data.map(function (d) {
                return d[xCol];
            })); // The domain of the X axis is the list of states.
        var y = d3.scaleRadial()
            .range([innerRadius, outerRadius])   // Domain will be define later.
            .domain([0, 100000]); // Domain of Y is from 0 to the max seen in the data

        var ybis = d3.scaleRadial()
            .range([innerRadius, 5])   // Domain will be defined later.
            .domain([0, 100000]);

        // Add the bars
        svg.append("g")
            .selectAll("path")
            .data(data)
            .enter()
            .append("path")
            .attr("fill", "#69b3a2")
            .attr("d", d3.arc()     // imagine your doing a part of a donut plot
                .innerRadius(innerRadius)
                .outerRadius(function (d) {
                    return y(d[yCol[1]] - d[yCol[0]]);
                })
                .startAngle(function (d) {
                    return x(d[xCol]);
                })
                .endAngle(function (d) {
                    return x(d[xCol]) + x.bandwidth();
                })
                .padAngle(0.01)
                .padRadius(innerRadius))

        svg.append("g")
            .selectAll("g")
            .data(data)
            .enter()
            .append("g")
            .attr("text-anchor", function (d) {
                return (x(d[xCol]) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "end" : "start";
            })
            .attr("transform", function (d) {
                return "rotate(" + ((x(d[xCol]) + x.bandwidth() / 2) * 180 / Math.PI - 90) + ")" + "translate(" + (y(d[yCol[0]]) + 10) + ",0)";
            })
            .append("text")
            .text(function (d) {
                return (d[xCol])
            })
            .attr("transform", function (d) {
                return (x(d[xCol]) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) < Math.PI ? "rotate(180)" : "rotate(0)";
            })
            .style("font-size", "11px")
            .attr("alignment-baseline", "middle")
        svg.append("g")
            .selectAll("path")
            .data(data)
            .enter()
            .append("path")
            .attr("fill", "red")
            .attr("d", d3.arc()     // imagine your doing a part of a donut plot
                .innerRadius(function (d) {
                    return ybis(0)
                })
                .outerRadius(function (d) {
                    return ybis(d[yCol[0]]);
                })
                .startAngle(function (d) {
                    return x(d[xCol]);
                })
                .endAngle(function (d) {
                    return x(d[xCol]) + x.bandwidth();
                })
                .padAngle(0.01)
                .padRadius(innerRadius))
    }

    function generateProgressBars(elem, data, xCol, yCol) {
        elem = (elem[0] === '#') ? elem : `#${elem}`;
        data.sort((a, b) => b[yCol[0]] - a[yCol[0]])
        let dataLength = (data.length < 5) ? 1 : data.length / 5
        let am = autoMargin(elem, 250, 5, 5, .9, dataLength)
        let xVal = 10
        let barHeight = 20
        let spacing = 50
        let scale = d3.scaleLinear()
            .domain([0, 1])
            .range([0, am.width]);
        am.svg.selectAll("g")
            .data(data)
            .enter()
            .append("rect")
            .attr("x", xVal)
            .attr("y", function (d, i) {
                return barHeight + i * spacing
            })
            .attr("height", barHeight)
            .attr("width", function (d) {
                return scale(scale.domain()[1])
            })
            .attr("rx", 5)
            .attr("ry", 5)
            .style("fill", "#ddd");

        am.svg.selectAll("g")
            .data(data)
            .enter()
            .append("rect")
            .attr("x", xVal)
            .attr("y", function (d, i) {
                return barHeight + i * spacing
            })
            .attr("height", barHeight)
            .attr("width", function (d) {
                return scale(d[yCol[0]] / d[yCol[1]])
            })
            .attr("rx", 5)
            .attr("ry", 5)
            .style("fill", "#5bc0de");

        am.svg.selectAll("g")
            .data(data)
            .enter()
            .append("text")
            .attr("x", am.width - (4 * xVal))
            .attr("y", function (d, i) {
                return barHeight + i * spacing
            })
            .attr("height", barHeight)
            .text(function (d) {
                return Math.round((d[yCol[0]] / d[yCol[1]]) * 100) + "%"
            })
        am.svg.selectAll("g")
            .data(data)
            .enter()
            .append("text")
            .attr("x", xVal)
            .attr("y", function (d, i) {
                return barHeight + i * spacing
            })
            .attr("height", barHeight)
            .text(function (d) {
                return d[xCol]
            })
    }

    function animateValue(obj, end, duration, displayValue) {
        let startTimestamp = null;
        const step = (timestamp) => {
            let start = Number(obj.innerHTML.replace(/[^0-9.-]+/g,""));
            if (!startTimestamp) startTimestamp = timestamp;
            const progress = Math.min((timestamp - startTimestamp) / duration, 1);
            obj.innerHTML = Math.floor(progress * (end - start) + start);
            if (progress < 1) {
                window.requestAnimationFrame(step);
            }
            else {
                obj.innerHTML = displayValue;
            }
        };
        window.requestAnimationFrame(step);
    }

    function generateTotalCards(elem, data, xCol, yCol) {
        elem = elem.replace('#', '');
        data.forEach(function (d) {
            let totalCardElem = document.getElementById('totalCard' + d['name']);
            if (totalCardElem === null) {
                let curElem = document.getElementById(elem);
                curElem.innerHTML += `
                    <div id="totalCard` + d['name'] + `" class="card col mb-auto shadow-sm">
                    <div class="card-body p-3">
                    <h3 class="text-muted small">` + d['name'].toUpperCase().replace('ESTIMATED_', 'e').split('_').join(' ') + `</h3>
                    <h5 id="totalCardValue` + d['name'] + `" class="text-large" style="text-align:center">
                    ` + d['current_value'] + `</h5>
                    </div>
                    <div class="card-footer p-2 d-flex align-items-center justify-content-center">
                    <p id="totalCardChange` + d['name'] + `" class="text-muted small">
                    ` + (d['change'] * 100).toFixed(2) + `% ` + d['msg'] + ` </p>
                    </div>
                    </div>`
            }
            else {
                let changeElem = document.getElementById("totalCardValue" + d['name']);
                animateValue(changeElem, d['numeric_value'], 500, d['current_value'])
                changeElem = document.getElementById("totalCardChange" + d['name']);
                animateValue(changeElem, d['change'], 500, (d['change'] * 100).toFixed(2) + `% ` + d['msg'])
            }
        });
    }

    function generateKpiNotes(elem, data, xCol, yCol) {
        elem = elem.replace('#', '');
        document.getElementById(elem).innerHTML = `
                                    <p id="dailyMetricsNotes0"></p>
                                    <br>
                                    <p id="dailyMetricsNotes1"></p>
                                    <br>`;

        function update(selectedVar, pos) {
            let curElem = document.getElementById(elem + pos);
            if (curElem) {
                curElem.innerHTML = '';
                data.forEach(function (d) {
                    if (d['index'] === 'Trend') {
                        if (d[selectedVar]) {
                            curElem.innerText += d[selectedVar]
                        }
                    } else {
                        if (d[selectedVar]) {
                            curElem.innerHTML += `<li>` + d[selectedVar] + `</li>`
                        }
                    }
                })
            }
        }

        let pos0 = '0';
        let pos1 = '1';
        let selectorElem = `#${elem.replace('Notes', '')}ChartPlaceholderSelect`;
        addOnClickEvent(selectorElem + pos0, function (e) {
            let selectedOption = $(e.currentTarget).val();
            update(selectedOption, pos0)
        }, 'change', true, false);
        addOnClickEvent(selectorElem + pos1, function (e) {
            let selectedOption = $(e.currentTarget).val();
            update(selectedOption, pos1)
        }, 'change', true, false);
        let keys = Object.keys(data[0]).filter(key => key !== 'index');
        update(keys[keys.length - 1], pos0);
        update(keys[keys.length - 2], pos1);
    }

    function getMetricsComplete(data, addSelect, elem) {
        let functionName = data['data']['args']['return_func'];
        let chartData = data['data']['data'];
        let xCol = data['data']['args']['dimensions'];
        let yCol = data['data']['args']['metrics'];
        let filterDict = data['data']['args']['filter_dict'];
        if (Array.isArray(chartData) && chartData.length) {
            yCol = Object.keys(chartData[0]).filter(function (e) {
                return e !== 'index' && e !== xCol[0]
            });
            document.getElementById(elem).innerHTML = "";
            let createVisualFunc = getChartFunction(functionName);
            createVisualFunc(elem, chartData, xCol, yCol, filterDict);
            if (addSelect) {
                addSelectOptions(chartData, xCol, false, "", false)
            }
        }
    }

    function getDownloadProgressForRadial(tableName, chart, downloadingProgress,
                                          procId = null, forceReturn = false,
                                          xCol = null, yCol = null,
                                          createVisualFunction = null,
                                          filterDict = null, addSelect = null,
                                          elem = null, task = null,
                                          oldHtml = null, clickElem = null) {
        downloadingProgress = setInterval(function () {
            $.post('/get_task_progress',
                {
                    object_type: "{{ title }}",
                    object_name: "{{ object_name }}",
                    object_level: "{{ edit_name }}",
                    task_name: tableName,
                    object_id: procId,
                    task: task
                }).done(function (data, status) {
                    let newPercent = data['percent'];
                    chart.update(parseInt(newPercent))
                    if (!forceReturn && 'data' in data) {
                        getMetricsComplete(chart, data['data'], xCol, yCol,
                            createVisualFunction, filterDict, addSelect, elem);
                        turnOffRadialProgress(elem, downloadingProgress, oldHtml, clickElem);
                    }
            });
        }, 5000);
        return downloadingProgress
    }

    function turnOffRadialProgress(elem, downloadingProgress, oldHtml, clickElem) {
        $(elem + 'Progress').remove()
        clearInterval(downloadingProgress);
        if (oldHtml) {
            $(clickElem).prop("disabled", false);
            $(clickElem).html(oldHtml);
            unanimateBar();
        }
    }

    /**
     * Builds arg dict for /get_table route and subsequently passed to
     * get_liquid_table_from_db task.
     *
     * use_cache: Determines whether to use stored values in db.
     * proc_id: Processor ID.
     * table_name: Table Name in html.
     * chart_show: Boolean of whether to default to showing table or chart.
     * return_func: Desired chart builder javascript function
     *              (e.g. generateBarChart).
     * dimensions: Array of table and chart dimensions -- db names.
     * metrics: Array of table and chart metrics -- db names.
     * filter_dict: Dictionary of filters to filter to e.g. select campaigns or
     *              dates.
     */
    function getDataTableArgsDict(return_func='', dimensions=[], metrics = [],
                                  filter_dict = [], use_cache, proc_id,
                                  table_name, chart) {
        const dataTableArgs = {};
        if (typeof use_cache !== 'undefined') {
            dataTableArgs['use_cache'] = true;
        }
        if (typeof proc_id !== 'undefined') {
            dataTableArgs['proc_id'] = proc_id;
        }
        if (typeof table_name !== 'undefined') {
            dataTableArgs['table_name'] = table_name;
        }
        if (typeof use_cache !== 'undefined') {
            dataTableArgs['chart_show'] = chart;
        }
        dataTableArgs['return_func'] = return_func;
        dataTableArgs['dimensions'] = dimensions;
        dataTableArgs['metrics'] = metrics;
        dataTableArgs['filter_dict'] = filter_dict;
        return dataTableArgs;
    }

    function addEdit(tableID, cols, buttonID) {
        const rows = document.getElementById(tableID).getElementsByTagName('tr');
        const colIndices = [];
        for (let j = 0, col; col = rows[0].cells[j]; j++) {
            if (cols.includes(rows[0].cells[j].innerHTML)) {
              colIndices.push(j);
            }
        }
        for (let i = 0; i < colIndices.length; i++) {
            for (let j = 1, row; row = rows[j]; j++) {
                rows[j].cells[colIndices[i]].setAttribute("contenteditable", "true");
                rows[j].cells[colIndices[i]].setAttribute("spellcheck", "false");
            }
        }
        cols = cols.join("','");
        cols = "['" +  cols + "']";
        const functionString = "overWritePlannedwPacing('" + tableID + "', " + cols + ")";
        const saveElem = document.getElementById(buttonID);
        saveElem.setAttribute("onclick", functionString);
        $('td').blur(function () {
            $('#' + buttonID).removeAttr('disabled');
            $('#' + buttonID).attr("class", "btn btn-success");
        });
    }

    function overWritePlannedwPacing(tableID, cols) {
        const tableName = 'dictionaryvendorkeyPlan___Net';
        let tid = 'Pacing Table';
        let data = getTableAsArray(tid, cols);
        SendDataTable(tableName, null, '', '', data, [], 'pacingTableSaveButton');
    }

    function getProgBars(tableName, progCol, paceCol, startCol) {
        const rows = document.getElementById(tableName).getElementsByTagName('tr');
        let progColInd = 0;
        let paceColInd = 0;
        let startColInd = 0;
        for (let j = 0, col; col = rows[0].cells[j]; j++) {
            if (rows[0].cells[j].innerHTML === progCol) {
                progColInd = j;
            }
            if (rows[0].cells[j].innerHTML === paceCol) {
                paceColInd = j;
            }
            if (rows[0].cells[j].innerHTML === startCol) {
                startColInd = j;
            }
        }
        let style, backgroundColor, delv, pace, today, sd, tooltip, delvColor;
        for (let i = 1, row; row = rows[i]; i++) {
            if (window.getComputedStyle) {
                style = window.getComputedStyle(row.cells[progColInd]);
            } else {
                style = row.cells[progColInd].currentStyle;
            }
            backgroundColor = style.backgroundColor;
            row.cells[progColInd].style.height = "100%";
            row.cells[progColInd].style.border = "1px solid #dee2e6";
            row.id = "tr" + String(i - 1);
            delv = row.cells[progColInd].innerHTML;
            pace = row.cells[paceColInd].innerHTML;
            delv = delv.slice(0, -1);
            pace = pace.slice(0, -1);
            delv = parseInt(delv);
            pace = parseInt(pace);
            today = today = new Date();
            sd = new Date(row.cells[startColInd].innerHTML);
            if (pace > 100) {
                pace = 100;
            }
            tooltip = "Delivery: " + delv + "% \nExpected Delivery: "
                + pace + "%";
            getTooltip(tooltip, row.cells[progColInd]);
            if ((delv > 105) || ((delv / pace) > 1.15)) {
                delvColor = "#dc3545cc";
            } else {
                delvColor = "#0d6efdcc";
            }
            if (sd >= today && delv <= 2) {
                row.cells[progColInd].style.background = "linear-gradient(to right, " + delvColor + " 2%, "
                    + "#ffc107cc 2% 4%, "
                    + backgroundColor + " 4%)";
            } else if (sd >= today && delv > 2) {
                row.cells[progColInd].style.background = "linear-gradient(to right, #ffc107cc 2%, "
                    + delvColor + " 2% " + delv + "%, "
                    + backgroundColor + " " + delv + "%)";
            } else if (pace >= 98 && delv >= 98) {
                row.cells[progColInd].style.background = "linear-gradient(to right,  " + delvColor + " 98%, "
                    + "#ffc107cc 98%)";
            } else if (pace >= 98 && delv < 98) {
                row.cells[progColInd].style.background = "linear-gradient(to right, " + delvColor + " "
                    + delv + "%, "
                    + backgroundColor + " " + delv + "% " + "98%, "
                    + "#ffc107cc 98%)";
            } else if (pace < 98 && delv >= 98) {
                row.cells[progColInd].style.background = "linear-gradient(to right, " + delvColor + " "
                    + pace + "%, "
                    + "#ffc107cc " + pace + "% " + (pace + 2) + "%, "
                    + delvColor + " " + (pace + 2) + "%)";
            } else if (Math.abs(pace - delv) <= 2) {
                row.cells[progColInd].style.background = "linear-gradient(to right, " + delvColor + " "
                    + delv + "%, "
                    + "#ffc107cc " + delv + "% " + (delv + 2) + "%, "
                    + backgroundColor + " " + (delv + 2) + "%)";
            } else if (pace < delv) {
                row.cells[progColInd].style.background = "linear-gradient(to right, " + delvColor + " "
                    + pace + "%, "
                    + "#ffc107cc " + pace + "% " + (pace + 2) + "%, "
                    + delvColor + " " + (pace + 2) + "% " + delv + "%, "
                    + backgroundColor + " " + delv + "%)";
            } else if (pace > delv) {
                row.cells[progColInd].style.background = "linear-gradient(to right,  " + delvColor + " "
                    + delv + "%, "
                    + backgroundColor + " " + delv + "% " + pace + "%, "
                    + "#ffc107cc " + pace + "% " + (pace + 2) + "%, "
                    + backgroundColor + " " + (pace + 2) + "%)";
            }
        }
    }

    function convertToFlareFormat(data, cols) {
        const flare = {name: cols[0], children: []};

        // Group the data
        const groupedData = data.reduce((acc, obj) => {
            const typeName = obj[cols[0]];
            if (!acc[typeName]) {
                acc[typeName] = [];
            }
            acc[typeName].push(obj);
            return acc;
        }, {});

        // Convert the grouped data to the desired format
        for (const typeName in groupedData) {
            const typeChildren = groupedData[typeName].map(obj => {
                return {
                    name: obj[cols[1]],
                    size: obj[cols[2]]
                };
            });

            flare.children.push({
                name: typeName,
                children: typeChildren
            });
        }

        return flare;
    }

    function generateTreeMap(elem, data, xCol, yCol) {
        // Requires data columns to be ordered by: dimension grouping,
        // dimension, metric
        let cols = [];
        Object.keys(data[0]).forEach(function(key) {
            cols.unshift(key);
        });
        data.sort((a, b) => b[cols[0]] - a[cols[0]]);
        let dataLength = (data.length < 5) ? 1 : data.length / 5;
        let am = autoMargin(elem, 250, 5, 5, .9, dataLength);
        let format = d3.format(getUnits(cols[2]));
        let tooltipFormat = d3.format(getUnits(cols[2], ',.4f'));
        let flare = convertToFlareFormat(data, cols);
        let chart = Treemap(flare, {
            value: d => d.size, // size of each node (file); null for internal nodes (folders)
            group: (d, n) => n.ancestors().slice(-2)[0].data.name, // e.g., "animate" in flare/animate/Easing; color
            label: (d, n) => [...d.name.split(/(?=[A-Z][a-z])/g), format(n.value)].join("\n"),
            title: (d, n) => `${n.ancestors().reverse().map(d => d.data.name).join("- ")}\n${tooltipFormat(n.value)}`,
            width: am.width,
            height: am.height,
            marginTop: am.margin.top,
            marginRight: am.margin.right,
            marginBottom: am.margin.bottom,
            marginLeft: am.margin.left,
        });
        d3.select(elem).select("svg").remove();
        d3.select(elem).node().appendChild(chart)
    }

    // Copyright 2021 Observable, Inc.
    // Released under the ISC license.
    // https://observablehq.com/@d3/treemap
    function Treemap(data, { // data is either tabular (array of objects) or hierarchy (nested objects)
        path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes
        id = Array.isArray(data) ? d => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)
        parentId = Array.isArray(data) ? d => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier
        children, // if hierarchical data, given a d in data, returns its children
        value, // given a node d, returns a quantitative value (for area encoding; null for count)
        sort = (a, b) => d3.descending(a.value, b.value), // how to sort nodes prior to layout
        label, // given a leaf node d, returns the name to display on the rectangle
        group, // given a leaf node d, returns a categorical value (for color encoding)
        title, // given a leaf node d, returns its hover text
        link, // given a leaf node d, its link (if any)
        linkTarget = "_blank", // the target attribute for links (if any)
        tile = d3.treemapBinary, // treemap strategy
        width = 640, // outer width, in pixels
        height = 400, // outer height, in pixels
        margin = 0, // shorthand for margins
        marginTop = margin, // top margin, in pixels
        marginRight = margin, // right margin, in pixels
        marginBottom = margin, // bottom margin, in pixels
        marginLeft = margin, // left margin, in pixels
        padding = 1, // shorthand for inner and outer padding
        paddingInner = padding, // to separate a node from its adjacent siblings
        paddingOuter = padding, // shorthand for top, right, bottom, and left padding
        paddingTop = paddingOuter, // to separate a node’s top edge from its children
        paddingRight = paddingOuter, // to separate a node’s right edge from its children
        paddingBottom = paddingOuter, // to separate a node’s bottom edge from its children
        paddingLeft = paddingOuter, // to separate a node’s left edge from its children
        round = true, // whether to round to exact pixels
        colors = d3.schemeTableau10, // array of colors
        zDomain, // array of values for the color scale
        fill = "#ccc", // fill for node rects (if no group color encoding)
        fillOpacity = group == null ? null : 0.6, // fill opacity for node rects
        stroke, // stroke for node rects
        strokeWidth, // stroke width for node rects
        strokeOpacity, // stroke opacity for node rects
        strokeLinejoin, // stroke line join for node rects
    } = {}) {

        // If id and parentId options are specified, or the path option, use d3.stratify
        // to convert tabular data to a hierarchy; otherwise we assume that the data is
        // specified as an object {children} with nested objects (a.k.a. the “flare.json”
        // format), and use d3.hierarchy.
        const root = path != null ? d3.stratify().path(path)(data)
            : id != null || parentId != null ? d3.stratify().id(id).parentId(parentId)(data)
                : d3.hierarchy(data, children);

        // Compute the values of internal nodes by aggregating from the leaves.
        value == null ? root.count() : root.sum(d => Math.max(0, value(d)));

        // Prior to sorting, if a group channel is specified, construct an ordinal color scale.
        const leaves = root.leaves();
        const G = group == null ? null : leaves.map(d => group(d.data, d));
        if (zDomain === undefined) zDomain = G;
        zDomain = new d3.InternSet(zDomain);
        const color = group == null ? null : d3.scaleOrdinal(zDomain, colors);

        // Compute labels and titles.
        const L = label == null ? null : leaves.map(d => label(d.data, d));
        const T = title === undefined ? L : title == null ? null : leaves.map(d => title(d.data, d));

        // Sort the leaves (typically by descending value for a pleasing layout).
        if (sort != null) root.sort(sort);

        // Compute the treemap layout.
        d3.treemap()
            .tile(tile)
            .size([width - marginLeft - marginRight, height - marginTop - marginBottom])
            .paddingInner(paddingInner)
            .paddingTop(paddingTop)
            .paddingRight(paddingRight)
            .paddingBottom(paddingBottom)
            .paddingLeft(paddingLeft)
            .round(round)
            (root);

        const svg = d3.create("svg")
            .attr("viewBox", [-marginLeft, -marginTop, width, height])
            .attr("width", width)
            .attr("height", height)
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
            .attr("font-family", "sans-serif")
            .attr("font-size", 10);

        const node = svg.selectAll("a")
            .data(leaves)
            .join("a")
            .attr("xlink:href", link == null ? null : (d, i) => link(d.data, d))
            .attr("target", link == null ? null : linkTarget)
            .attr("transform", d => `translate(${d.x0},${d.y0})`);

        node.append("rect")
            .attr("fill", color ? (d, i) => color(G[i]) : fill)
            .attr("fill-opacity", fillOpacity)
            .attr("stroke", stroke)
            .attr("stroke-width", strokeWidth)
            .attr("stroke-opacity", strokeOpacity)
            .attr("stroke-linejoin", strokeLinejoin)
            .attr("width", d => d.x1 - d.x0)
            .attr("height", d => d.y1 - d.y0);

        if (T) {
            node.append("title").text((d, i) => T[i]);
        }

        if (L) {
            // A unique identifier for clip paths (to avoid conflicts).
            const uid = `O-${Math.random().toString(16).slice(2)}`;

            node.append("clipPath")
                .attr("id", (d, i) => `${uid}-clip-${i}`)
                .append("rect")
                .attr("width", d => d.x1 - d.x0)
                .attr("height", d => d.y1 - d.y0);

            node.append("text")
                .attr("clip-path", (d, i) => `url(${new URL(`#${uid}-clip-${i}`, location)})`)
                .selectAll("tspan")
                .data((d, i) => `${L[i]}`.split(/\n/g))
                .join("tspan")
                .attr("x", 3)
                .attr("y", (d, i, D) => `${(i === D.length - 1) * 0.3 + 1.1 + i * 0.9}em`)
                .attr("fill-opacity", (d, i, D) => i === D.length - 1 ? 0.7 : null)
                .text(d => d);
        }

        return Object.assign(svg.node(), {scales: {color}});
    }


    function getTooltip(content, cell){
        cell.setAttribute("class", "dropdown-item");
        cell.setAttribute("data-bs-toggle", "hover");
        cell.setAttribute("data-placement", "bottom");
        cell.setAttribute("title", content);
        cell.style.height = "100%"
    }

    function addAccordianSetup(tableName) {
        const rows = document.getElementById(tableName).getElementsByTagName('tr');
        for (let i = 1, row; row = rows[i]; i++) {
            let expandButtonHTML = `<button class="btn btn-primary btn-sm bi bi-chevron-up collapsed"
                data-bs-target="#collapseRow` + (i-1) + `" data-bs-toggle="collapse"
                aria-expanded="False" type="button" style="color:white">
                </button>`;
            let expandCell = rows[i].insertCell(-1);
            expandCell.innerHTML = expandButtonHTML;
        }
    }

    function hideColumn(tableName, colName) {
        const rows = document.getElementById(tableName).getElementsByTagName('tr');
        let colInd = 0;
        for (let j = 0, col; col = rows[0].cells[j]; j++) {
            if (rows[0].cells[j].innerHTML === colName) {
                colInd = j;
            }
        }
        for (let i = 0, row; row = rows[i]; i++) {
            rows[i].cells[colInd].style.display = "none";
        }
    }

    function addSort(tableName, bodyName) {
        const headerId = 'pacingHeader';
        const rows = document.getElementById(tableName).getElementsByTagName('tr');
        rows[0].parentNode.id = headerId;
        sortTable(bodyName, headerId)
    }

    function addConditionalArrows(tableName, colName, threshold) {
        const rows = document.getElementById(tableName).getElementsByTagName('tr');
        let colInd = 0;
        rows[0].id = 'thHidden';
        for (let j = 0, col; col = rows[0].cells[j]; j++) {
            if (rows[0].cells[j].innerHTML === colName) {
              colInd = j;
            }
            rows[0].cells[j].id = 'thHidden'
        }
        let icon;
        for (let i = 1, row; row = rows[i]; i++) {
            row.id = tableName + 'trHidden' + i;
            let val = rows[i].cells[colInd].innerHTML;
            val = parseFloat(val)
            if (Math.abs(val) > parseFloat(threshold)) {
                if (val > 0) {
                    icon = `<i>  </i><i class="bi bi-arrow-up" style="color: #00C851"></i>`;
                }
                if (val < 0) {
                    icon = `<i>  </i><i class="bi bi-arrow-down" style="color: #ff4444"></i>`;
                }
                let iconCell = rows[i].cells[colInd]
                iconCell.innerHTML += icon
            }
        }
    }

    function generateAlertCount(elem, data, xCol, yCol) {
        const elemID = elem.replace('#', '');
        elem = document.getElementById(elemID);
        elem.innerHTML = data[0]['count'];
    }

    function generateAlerts(elem, data, xCol, yCol) {
        const alertElem = document.getElementById("pacingAlerts");
        let alertHtml;
        for (let i = 0, datum; datum = data[i]; i++) {
            alertHtml = `<div class="alert alert-danger" role="alert" style="white-space: pre-line">`
                + datum['msg'] + `</div>`;
            alertElem.innerHTML += alertHtml;
        }
    }

    function getChartFunctionName(chartType) {
        let chartName = {
            'Histogram': 'generateHistogram',
            'Line': 'generateLineChart',
            'Area': 'generateAreaChart',
            'Dual Line': 'generateDualLineChart',
            'Lollipop': 'generateLollipopChart',
            'Mini': 'generateMiniChart',
            'Bubble': 'generateBubbleChart',
            'Bar': 'generateBarChart',
            'World Map': 'generateWorldMap',
            'Circular Barplot': 'generateCircularBarplot',
            'Progress Bars': 'generateProgressBars',
            'Total Cards': 'generateTotalCards',
            'Kpi Notes': 'generateKpiNotes',
        };
        return chartName[chartType]
    }

    function getChartFunction(chartFuncString){
        let chartTypes = {
            'generateHistogram': generateHistogram,
            'generateLineChart': generateLineChart,
            'generateAreaChart': generateAreaChart,
            'generateDualLineChart': generateDualLineChart,
            'generateLollipopChart': generateLollipopChart,
            'generateMiniChart': generateMiniChart,
            'generateBubbleChart': generateBubbleChart,
            'generateBarChart': generateBarChart,
            'generateWorldMap': generateWorldMap,
            'generateCircularBarplot': generateCircularBarplot,
            'generateProgressBars': generateProgressBars,
            'generateTotalCards': generateTotalCards,
            'generateKpiNotes': generateKpiNotes,
            'generateAlertCount': generateAlertCount,
            'generateAlerts': generateAlerts
        };
        return chartTypes[chartFuncString]
    }

    function radialProgress(selector) {
        const parent = d3.select(selector)
        const size = parent.node().getBoundingClientRect()
        const svg = parent.append('svg')
            .attr('width', size.width)
            .attr('height', size.height);
        const outerRadius = Math.min(size.width, size.height) * 0.45;
        const thickness = 10;
        let value = 0;

        const mainArc = d3.arc()
            .startAngle(0)
            .endAngle(Math.PI * 2)
            .innerRadius(outerRadius - thickness)
            .outerRadius(outerRadius)

        svg.append("path")
            .attr('class', 'radial-progress-bar-bg')
            .attr('transform', `translate(${size.width / 2},${size.height / 2})`)
            .attr('d', mainArc())

        const mainArcPath = svg.append("path")
            .attr('class', 'radial-progress-bar')
            .attr('transform', `translate(${size.width / 2},${size.height / 2})`)

        svg.append("circle")
            .attr('class', 'radial-progress-bar')
            .attr('transform', `translate(${size.width / 2},${size.height / 2 - outerRadius + thickness / 2})`)
            .attr('width', thickness)
            .attr('height', thickness)
            .attr('r', thickness / 2)

        const end = svg.append("circle")
            .attr('class', 'radial-progress-bar')
            .attr('transform', `translate(${size.width / 2},${size.height / 2 - outerRadius + thickness / 2})`)
            .attr('width', thickness)
            .attr('height', thickness)
            .attr('r', thickness / 2)

        let percentLabel = svg.append("text")
            .attr('class', 'progress-label')
            .attr('transform', `translate(${size.width / 2},${size.height / 2})`)
            .text('0%')

        return {
            update: function (progressPercent) {
                const startValue = value
                const startAngle = Math.PI * startValue / 50
                const angleDiff = Math.PI * progressPercent / 50 - startAngle;
                const startAngleDeg = startAngle / Math.PI * 180
                const angleDiffDeg = angleDiff / Math.PI * 180
                const transitionDuration = 1500

                mainArcPath.transition().duration(transitionDuration).attrTween('d', function () {
                    return function (t) {
                        mainArc.endAngle(startAngle + angleDiff * t)
                        return mainArc();
                    }
                })
                end.transition().duration(transitionDuration).attrTween('transform', function () {
                    return function (t) {
                        return `translate(${size.width / 2},${size.height / 2})` +
                            `rotate(${(startAngleDeg + angleDiffDeg * t)})` +
                            `translate(0,-${outerRadius - thickness / 2})`
                    }
                })
                percentLabel.transition().duration(transitionDuration).tween('bla', function () {
                    return function (t) {
                        percentLabel.text(Math.round(startValue + (progressPercent - startValue) * t));
                    }
                })
                value = progressPercent
            }
        }
    }

    function staticFilterToSelectOptions(tableData, selectDiv, tableName){
        let xCol = tableData['data']['metadata']['dimensions'][0];
        document.getElementById(tableName).parentElement.style.display = "";
        addSelectOptions(tableData['data']['data'], xCol, `#${tableName}`)
    }


    function addSelectOptions(data, xCol, selectDiv=false, baseElemId='',
                              defaultValInd=0) {
        let i = 0;
        let newData = $.map(data, function (obj) {
            obj['text'] = obj['text'] || obj[xCol];
            obj['id'] = obj['text'] || obj[xCol];
            obj['value'] = obj['text'] || obj[xCol];
            i++;
            return obj;
        });
        let elemIdJquery = selectDiv ? selectDiv : "#" + xCol + "Select";
        let elemId = elemIdJquery.replace('#', '');
        let elem = document.getElementById(elemId);
        if (!(elem)) {
            let elemToAdd = `
                <select id="${elemId}" class="form-control form-control-sm">
                    <option>Select Metric</option>
                </select>`
            let baseElem = document.getElementById(baseElemId);
            if(!(baseElem)) {return}
            baseElem.insertAdjacentHTML('beforeend', elemToAdd);
            addSelectize();
        }
        let selectizeElem = $(elemIdJquery)[0].selectize;
        if (selectizeElem) {
            selectizeElem.load(function (callback) {
                callback(newData);
            });
            if (Number.isInteger(defaultValInd)) {
                selectizeElem.setValue(data[defaultValInd]['text'])
            }
        }
    }

    function getStaticFilterOptions(selectElement) {
        let selectedText = selectElement.options[selectElement.selectedIndex].text;
        let filterNum = selectElement.id.replace('filter_col', '');
        let elemId = filterNum + 'filter_val';
        const elem = document.getElementById(elemId);
        elem.innerHTML = '';
        elem.parentNode.style.display = 'none';
        const newDiv = document.createElement('div');
        newDiv.innerHTML = `<div id="${elemId}ProgressBar"></div>`;
        elem.parentNode.parentNode.appendChild(newDiv);
        let static_filter_args = getDataTableArgsDict(
            '', [selectedText], ['impressions'], [], true);
        getTable(elemId, `${elemId}ProgressBar`,
            'None', 'None', 'None', true, 'None', false, static_filter_args,
            staticFilterToSelectOptions);
    }

    function staticFilterChange() {
        $('select[id$="filter_col"]').selectize({
            plugins: ['drag_drop', 'remove_button', 'restore_on_backspace', 'clear_button'],
            onChange: function () {
                const selectElement = this.$input[0];
                getStaticFilterOptions(selectElement);
            }
        });
        let static_filters = document.querySelectorAll('select[id$="filter_col"]');
        static_filters.forEach(function (selectElement) {
            getStaticFilterOptions(selectElement);
        });
    }

    function addStaticFilterOnClick() {
        let form = document.getElementById('base_form_id');
        let formData = new FormData(form);
        makeRequest('/add_static_filter',
            'POST', formData, addDeleteStaticFilterResponse);
    }

    function addDeleteStaticFilterResponse(data) {
        document.getElementById('base_form_id').innerHTML = data['form'];
        loadJS();
        staticFilterChange();
    }

    function deleteStaticFilterOnClick(event) {
        let form = document.getElementById('base_form_id');
        let formData = new FormData(form);
        let delete_id = event.currentTarget.id;
        let url = '/delete_static_filter?delete_id='.concat(delete_id);
        makeRequest(url, 'POST', formData, addDeleteStaticFilterResponse);
    }

    function checkChartTypeOnChange (e) {
        let selectedText = this.options[e.target.selectedIndex].text;
        if ((selectedText === 'Area') || (selectedText === 'Line')) {
            let selectize = document.getElementById(`dimensions`).selectize;
            selectize.setValue('eventdate');
            selectize.disable();
        } else {
            let selectize = document.getElementById(`dimensions`).selectize;
            selectize.enable();
        }
    }

    document.addEventListener("DOMContentLoaded", function() {
         addOnClickEvent('#chart_type', checkChartTypeOnChange, 'change', false);
    });

</script>